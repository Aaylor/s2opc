/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
   service_mgr_i
REFINES
   service_mgr

SEES
   channel_mgr_bs,
   constants
   
IMPORTS
    message_in_bs,
    message_out_bs,
    session_mgr,
    session_async_bs,
    service_read,
    request_handle_bs,
    service_response_cli_cb_bs,
    address_space,
    service_write_decode_bs
    
PROMOTES
    /* messages_in_bs */
    decode_msg_type,
    is_valid_msg_in_type,
    
    /* session_mgr */
    client_secure_channel_lost,
    server_secure_channel_lost 
    
LOCAL_OPERATIONS
    
    resp_msg_typ <-- get_response_type (req_msg_typ) =
    PRE
        req_msg_typ : t_msg_type_i &
        req_msg_typ : t_msg_type &
        req_msg_typ : s_service_reqs
    THEN
        resp_msg_typ :(resp_msg_typ : t_msg_type_i &
                       resp_msg_typ : t_msg_type &
                       resp_msg_typ : s_service_resps)
    END
    ;

    treat_read_request(p_request_msg, p_response_msg) =
    PRE
        p_request_msg  : t_msg_i   &
        p_request_msg  = c_msg_in  &
        p_response_msg : t_msg_i   &
        p_response_msg = c_msg_out
    THEN
        nb_ReadValue,
        ReadValue_NodeId,
        ReadValue_AttributeId,
        data_Value_Value,
        data_Value_StatusCode
        :(
          nb_ReadValue          : NAT                           &
          nb_ReadValue         <= k_n_read_resp_max             &
          ReadValue_NodeId      : t_ReadValue +-> t_NodeId      &
          ReadValue_AttributeId : t_ReadValue +-> t_AttributeId &
          data_Value_Value      : t_ReadValue +-> t_Variant     &
          data_Value_StatusCode : t_ReadValue +-> t_StatusCode
         )
    END
    ;
    
    /* TODO: call the treat write on an encoded WriteRequest */
    /* TODO: add constraints on userid? */
    StatusCode_service <-- treat_write_request(write_msg, userid) =
    PRE
        write_msg : t_msg_i &
        write_msg = c_msg_in &
        c_msg_in : t_msg &
        a_msg_in_type = e_msg_session_write_req &
        userid : t_user_i &
        userid : t_user
    THEN
        StatusCode_service
        :(  StatusCode_service : t_StatusCode_i &
            StatusCode_service : t_StatusCode
        )
    END
	;

    local_create_session (session, channel) =
    PRE
        session : t_session_i &
        session : t_session &
        channel : t_channel_i &
        channel : t_channel &
        channel : s_channel_connected &
        c_msg_out = c_msg_indet
    THEN
        skip
    END
    ;
    
    local_sc_activate_orphaned_sessions (channel_config_idx, channel) =
    PRE
        channel : t_channel_i &
        channel : t_channel &
        channel_config_idx : t_channel_config_idx_i &
        channel_config_idx : t_channel_config_idx
    THEN
        skip
    END
    ;
    
    ret <-- local_activate_session (session, user) =
    PRE
        session : t_session_i &
        session : t_session &
        user : t_user_i &
        user : t_user &
        c_msg_out = c_msg_indet
    THEN
        ret :: {e_sc_ok, 
            e_sc_bad_out_of_memory,
            e_sc_bad_invalid_argument,
            e_sc_bad_invalid_state,          /* session not in a valid state to activate a user on it */
            e_sc_bad_unexpected_error,
            e_sc_bad_identity_token_invalid, /* user identity invalid */
            e_sc_bad_encoding_error,
            e_sc_bad_secure_channel_closed,
            e_sc_bad_connection_closed,
            e_sc_bad_encoding_error}
    END
    

OPERATIONS
    
    resp_msg_typ <-- get_response_type (req_msg_typ) =
    BEGIN
        CASE req_msg_typ OF
            EITHER e_msg_public_service_req THEN
                resp_msg_typ := e_msg_public_service_resp
            OR e_msg_session_create_req THEN
                resp_msg_typ := e_msg_session_create_resp
            OR e_msg_session_activate_req THEN
                resp_msg_typ := e_msg_session_activate_resp
            OR e_msg_session_close_req THEN
                resp_msg_typ := e_msg_session_close_resp
            OR e_msg_session_read_req THEN
                resp_msg_typ := e_msg_session_read_resp
            OR e_msg_session_write_req THEN
                resp_msg_typ := e_msg_session_write_resp
            END
        END
    END
    ;

    treat_read_request(p_request_msg, p_response_msg) =
    VAR
        l_nb_ReadValue,
        l_is_valid
    IN
        l_is_valid, l_nb_ReadValue <-- check_ReadRequest(p_request_msg);
        IF  l_is_valid = TRUE THEN
            l_is_valid <-- alloc_read_response(l_nb_ReadValue, p_response_msg);
            IF  l_is_valid = TRUE THEN
                fill_read_response(p_request_msg, p_response_msg)
            END
        END
    END
    ;

    StatusCode_service <-- treat_write_request(write_msg, userid) =
    VAR
        l_nb_req
    IN
        StatusCode_service <-- decode_write_request(write_msg);
        IF StatusCode_service = e_sc_ok
        THEN
            l_nb_req <-- get_nb_WriteValue;
            StatusCode_service <-- alloc_write_request_responses(l_nb_req);
            IF StatusCode_service = e_sc_ok
            THEN
                StatusCode_service <-- treat_write_request_WriteValues(userid)
            END
        END;
        free_write_request
    END
    ;
    
    local_create_session (session, channel) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_req_handle,
        l_valid_req_handle,
        l_valid_msg,
        l_valid_session,
        l_buffer,
        l_valid_buffer,
        l_ret
    IN
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_create_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg_header = TRUE &
            l_valid_msg = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle  = TRUE
            THEN
                l_valid_session <-- is_valid_session (session);
                IF l_valid_session = TRUE
                THEN
                    l_ret <-- client_create_req (session, channel, l_req_handle, l_req_msg);
                    IF l_ret = e_sc_ok
                    THEN
                        
                        write_msg_out_header_req_handle (l_msg_header, l_req_handle);
                        l_buffer <-- encode_msg (e_msg_session_create_req, l_msg_header, l_req_msg);
                        l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                        IF l_valid_buffer = TRUE
                        THEN
                            l_ret <-- send_channel_msg_buffer (channel, l_buffer)
                        ELSE
                            /* allocation / encoding problem */
                            l_ret := e_sc_nok
                        END;
                        IF l_ret /= e_sc_ok
                        THEN
                            remove_req_handle (l_req_handle);
                            cli_close_session (session)
                        END
                    ELSE
                        remove_req_handle (l_req_handle);
                        cli_close_session (session)
                    END
                ELSE
                    cli_close_session (session)
                END
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        END
    END
    ;
    
    local_sc_activate_orphaned_sessions (channel_config_idx, channel) =
    VAR
        l_valid_new_channel,
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_valid_msg,
        l_continue,
        l_session,
        l_ret,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_valid_new_channel <-- is_connected_channel (channel);
        IF l_valid_new_channel = TRUE
        THEN
            l_continue <-- init_iter_orphaned_t_session (channel_config_idx);
            WHILE l_continue = TRUE
            DO
                l_session, l_continue <-- continue_iter_orphaned_t_session;
                l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
                l_valid_msg <-- is_valid_msg_out (l_req_msg);
                l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
                IF l_valid_msg = TRUE &
                    l_valid_msg_header = TRUE
                THEN
                    l_req_handle <-- fresh_req_handle;
                    l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                    IF l_valid_req_handle = TRUE
                    THEN
                        l_ret, l_session_token <-- client_sc_activate_req (l_session, l_req_handle, channel, l_req_msg);
                        IF l_ret = e_sc_ok
                        THEN
                            write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                            write_msg_out_header_session_token(l_msg_header, l_session_token);
                            l_buffer <-- encode_msg (e_msg_session_activate_req, l_msg_header, l_req_msg);
                            l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                            IF l_valid_buffer = TRUE
                            THEN
                                l_ret <-- send_channel_msg_buffer (channel, l_buffer)
                            ELSE
                                /* allocation / encoding problem */
                                l_ret := e_sc_nok
                            END;
                            /* TODO: something in case of failure ? */
                            IF l_ret /= e_sc_ok
                            THEN
                                remove_req_handle (l_req_handle);
                                cli_close_session (l_session)
                            END
                        END
                    END;
                    dealloc_msg_header_out (l_msg_header);
                    dealloc_msg_out (l_req_msg)
                END
            INVARIANT
                l_continue = bool(av_sessions_to_iterate /= {}) &
                av_sessions_to_iterate /\ av_sessions_iterated = {} &
                av_sessions_to_iterate \/ av_sessions_iterated = av_sessions_orphaned
            VARIANT
                card(av_sessions_to_iterate)
            END
        END
    END
    ;
    
    ret <-- local_activate_session (session, user) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_valid_msg,
        l_ret,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg = TRUE &
            l_valid_msg_header = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN
                l_ret, l_channel, l_session_token <-- client_user_activate_req (session, l_req_handle, user, l_req_msg);
                IF l_ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                    write_msg_out_header_session_token(l_msg_header, l_session_token);
                    l_buffer <-- encode_msg (e_msg_session_activate_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = TRUE
                    THEN
                        l_ret <-- send_channel_msg_buffer (l_channel, l_buffer)
                    ELSE
                        /* allocation / encoding problem */
                        l_ret := e_sc_nok
                    END;
                    IF l_ret /= e_sc_ok
                    THEN
                        remove_req_handle (l_req_handle);
                        cli_close_session (session)
                    END
                END
            ELSE
                l_ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        ELSE
            l_ret := e_sc_bad_out_of_memory
        END;
        ret := l_ret
    END
    ;
    
    /* END OF LOCAL OPERATIONS */
    
    server_receive_session_treatment_req (channel, req_typ, msg_buffer) =
    VAR
        l_req_msg_header,
        l_valid_req_header,
        l_checked_req_header,
        l_req_msg,
        l_valid_req,
        l_request_handle,
        l_session_token,
        l_resp_msg_typ,
        l_resp_msg,
        l_valid_msg,
        l_resp_msg_header,
        l_valid_resp_header,
        l_session,
        l_ret,
        l_buffer_out,
        l_valid_buffer
    IN
        l_req_msg_header <-- decode_msg_header (msg_buffer);
        l_valid_req_header <-- is_valid_msg_in_header (l_req_msg_header);
        IF l_valid_req_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_req_msg_header);
            l_session_token <-- read_msg_req_header_session_token (l_req_msg_header);
            /* TODOnow: check request handle and session token */
            l_checked_req_header := TRUE;
            IF l_checked_req_header = TRUE
            THEN
                l_req_msg <-- decode_msg (msg_buffer);
                l_valid_req <-- is_valid_msg_in (l_req_msg);
                IF l_valid_req = TRUE
                THEN
                    l_resp_msg_typ <-- get_response_type (req_typ);
                    l_resp_msg_header, l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ, l_req_msg);
                    l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                    l_valid_resp_header <-- is_valid_msg_out_header (l_resp_msg_header);
                    IF l_valid_msg = TRUE &
                        l_valid_resp_header = TRUE
                    THEN
                        l_session, l_ret <-- server_receive_session_req (channel, l_request_handle, l_session_token, l_req_msg, req_typ, l_resp_msg);
                        write_msg_resp_header_service_status (l_resp_msg_header, l_ret);
                        write_msg_out_header_req_handle (l_resp_msg_header, l_request_handle);
                        l_buffer_out <-- encode_msg (l_resp_msg_typ, l_resp_msg_header, l_resp_msg);
                        l_valid_buffer <-- is_valid_buffer_out (l_buffer_out);
                        IF l_valid_buffer = TRUE
                        THEN
                            l_ret <-- send_channel_msg_buffer (channel, l_buffer_out)
                        ELSE
                            /* allocation / encoding problem */
                            l_ret := e_sc_nok
                        END;
                        IF l_ret /= e_sc_ok
                        THEN
                            // TODO: store message to retry later ?
                            server_close_session (l_session)
                        END;
                        
                        /* response message structures not necessary anymore */
                        dealloc_msg_header_out (l_resp_msg_header);
                        dealloc_msg_out (l_resp_msg)
                    END;
                    /* request message not necessary anymore */
                    dealloc_msg_in (l_req_msg)
                END /* DECODE REQ CHECK */
            END /* VALID REQ HEADER CHECK */
        END; /* DECODE REQ HEADER CHECK */
        IF l_valid_req_header = TRUE
        THEN
            dealloc_msg_in_header (l_req_msg_header)
        END;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;
    
    client_receive_session_treatment_resp (channel, resp_typ, msg_buffer) =
    VAR
        l_resp_msg_header,
        l_valid_resp_header,
        l_checked_resp_header,
        l_resp_msg,
        l_valid_resp,
        l_request_handle,
        l_session,
        l_session_state,
        l_session_user,
        l_ret
    IN
        l_resp_msg_header <-- decode_msg_header (msg_buffer);
        l_valid_resp_header <-- is_valid_msg_in_header (l_resp_msg_header);
        IF l_valid_resp_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_resp_msg_header);
            /* TODOnow: check request handle and session token */
            l_checked_resp_header := TRUE;
            IF l_checked_resp_header = TRUE
            THEN
                l_resp_msg <-- decode_msg (msg_buffer);
                l_valid_resp <-- is_valid_msg_in (l_resp_msg);
                IF l_valid_resp = TRUE
                THEN
                    l_session <-- client_receive_session_resp (channel, l_request_handle, resp_typ, l_resp_msg_header, l_resp_msg);
                    remove_req_handle (l_request_handle);
                    
                    /* TODOnow: move this behavior in session mgr ? */
                    // If session is created, activate it with async data if present
                    l_session_state <-- get_session_state_or_closed (l_session);
                    IF l_session_state = e_session_created
                    THEN
                        l_session_user <-- is_session_to_activate (l_session);
                        IF l_session_user /= c_user_indet
                        THEN
                            l_ret <-- local_activate_session (l_session, l_session_user)
                        END
                    END;
                    /* resp message not used anymore => deallocate */
                    dealloc_msg_in (l_resp_msg)
                END /* DECODE RESP CHECK */
            END /* VALID RESP HEADER CHECK */
        END; /* DECODE RESP HEADER CHECK */
    
        IF l_valid_resp_header = TRUE
        THEN
            /* resp header message not used anymore => deallocate */
            dealloc_msg_in_header (l_resp_msg_header)
        END;
        
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;
    
    server_receive_session_service_req (channel, req_typ, msg_buffer) =
    VAR
        l_req_msg_header,
        l_valid_req_header,
        l_request_handle,
        l_session_token,
        l_checked_req_header,
        l_is_valid_req,
        l_session,
        l_snd_session_err,
        l_req_msg,
        l_valid_req,
        l_resp_msg_typ,
        l_resp_msg,
        l_valid_msg,
        l_resp_msg_header,
        l_valid_resp_header,
        l_session_user,
        l_ret,
        l_is_valid_resp,
        l_buffer_out,
        l_valid_buffer
    IN
        l_req_msg_header <-- decode_msg_header (msg_buffer);
        l_valid_req_header <-- is_valid_msg_in_header (l_req_msg_header);
        IF l_valid_req_header = TRUE
        THEN    
            l_request_handle <-- read_msg_header_req_handle (l_req_msg_header);
            l_session_token <-- read_msg_req_header_session_token (l_req_msg_header);
            l_is_valid_req, l_session, l_snd_session_err <-- server_validate_session_service_req (channel, l_request_handle, l_session_token);
            /* TODOnow: check request handle and session token */
            l_checked_req_header := TRUE;
            IF l_checked_req_header = TRUE &
                l_is_valid_req = TRUE
            THEN
                l_req_msg <-- decode_msg (msg_buffer);
                l_valid_req <-- is_valid_msg_in (l_req_msg);
                IF l_valid_req = TRUE
                THEN
                    IF l_is_valid_req = TRUE
                    THEN
                        l_resp_msg_typ <-- get_response_type (req_typ);
                        l_resp_msg_header, l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ, l_req_msg);
                        l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                        l_valid_resp_header <-- is_valid_msg_out_header (l_resp_msg_header);
                        IF l_valid_msg = TRUE &
                            l_valid_resp_header = TRUE
                        THEN
                            CASE req_typ OF
                                EITHER e_msg_session_read_req THEN
                                    treat_read_request (l_req_msg, l_resp_msg);
                                    /* TODO: set a returned status code result from read request */
                                    write_msg_resp_header_service_status (l_resp_msg_header, e_sc_ok)
                                OR e_msg_session_write_req THEN
                                    // Write request case
                                    l_session_user <-- get_session_user_or_indet (l_session);
                                    l_ret <-- treat_write_request (l_req_msg, l_session_user);
                                    write_msg_resp_header_service_status (l_resp_msg_header, l_ret);
                                    /* TODO: the following may fail (malloc) */
                                    write_WriteResponse_msg_out(l_resp_msg);
                                    dealloc_write_request_responses
                                END
                            END;
                            l_is_valid_resp, l_snd_session_err <-- server_validate_session_service_resp (channel, l_session, l_request_handle);
                            IF l_is_valid_resp = TRUE THEN
                                write_msg_out_header_req_handle (l_resp_msg_header, l_request_handle);
                                l_buffer_out <-- encode_msg (l_resp_msg_typ, l_resp_msg_header, l_resp_msg);
                                l_valid_buffer <-- is_valid_buffer_out (l_buffer_out);
                                IF l_valid_buffer = TRUE
                                THEN
                                    l_ret <-- send_channel_msg_buffer (channel, l_buffer_out)
                                ELSE
                                    /* allocation / encoding problem */
                                    l_ret := e_sc_nok
                                END
                            END;
                            /* response message structures not necessary anymore */
                            dealloc_msg_header_out (l_resp_msg_header);
                            dealloc_msg_out (l_resp_msg)
                        END;
                        /* request message not necessary anymore */
                        dealloc_msg_in (l_req_msg)
                    END
                END /* DECODE REQ CHECK */
            END /* VALID REQ HEADER CHECK */
        END; /* DECODE REQ HEADER CHECK */
        IF l_valid_req_header = TRUE
        THEN
            dealloc_msg_in_header (l_req_msg_header)
        END;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;
    
    client_receive_session_service_resp (channel, resp_typ, msg_buffer) =
    VAR
        l_resp_msg_header,
        l_valid_resp_header,
        l_request_handle,
        l_checked_resp_header,
        l_is_valid_session_resp,
        l_resp_msg,
        l_valid_resp_msg,
        l_status
    IN
        l_resp_msg_header <-- decode_msg_header (msg_buffer);
        l_valid_resp_header <-- is_valid_msg_in_header (l_resp_msg_header);
        IF l_valid_resp_header = TRUE
        THEN
        l_request_handle <-- read_msg_header_req_handle (l_resp_msg_header);
            l_is_valid_session_resp <-- client_validate_session_service_resp (channel, l_request_handle);
            /* TODOnow: check request handle and session token */
            l_checked_resp_header := TRUE;
            IF l_checked_resp_header = TRUE &
                l_is_valid_session_resp = TRUE
            THEN
                l_resp_msg <-- decode_msg (msg_buffer);
                l_valid_resp_msg <-- is_valid_msg_in (l_resp_msg);
                IF l_valid_resp_msg = TRUE    
                THEN
                    l_status <-- read_msg_resp_header_service_status (l_resp_msg_header);
                    cli_service_response (l_resp_msg, l_status)
                END /* DECODE RESP CHECK */
            END /* VALID RESP HEADER CHECK */
        END; /* DECODE RESP HEADER CHECK */
        /* For services on session IN response messages will be provided to applicative
        TODO: dealloc header if not provided to app and separated from the msg body
        TODOnow: unreference header/msg as current header/msg IN */
        skip;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;

    server_receive_public_service_req (channel, req_typ, msg_buffer) =
    BEGIN
        /* TODO: no public service treated for now => at least return service failure and deallocate */
        skip
    END
    ;

    client_receive_public_service_resp (channel, resp_typ, msg_buffer) =
    BEGIN
        /* TODO: no public service treated for now */
        skip
    END
    ;
    
    /* CLIENT EVENTS */
    
    /* CLIENT NETWORK EVENTS */
    client_channel_connected_event_service (channel_config_idx, channel) =
    VAR
        l_session_to_create
    IN
        // Re-associate orphaned sessions waiting for sc (if there are some)
        local_sc_activate_orphaned_sessions (channel_config_idx, channel);
        // Create session waiting for sc
        l_session_to_create <-- is_session_to_create (channel_config_idx);
        IF l_session_to_create /= c_session_indet
        THEN
            local_create_session (l_session_to_create, channel)
            // activation already registered as next async step
        END
    END    
    ;
    
    /* CLIENT APP EVENTS */
    bres <-- client_activate_new_session_wihtout_channel (channel_config_idx, user) =
    VAR
        l_session,
        l_valid_session
    IN
        l_session <-- client_init_session;
        l_valid_session <-- is_valid_session (l_session);
        IF l_valid_session = TRUE 
        THEN
            /* channel did not exist or is not connected anymore: add async session creation on SC connection */
            bres <-- add_session_to_create (l_session, channel_config_idx);
            IF bres = TRUE
            THEN
                bres <-- add_session_to_activate (l_session, user)
            END;
            IF bres = FALSE
            THEN
                /* Remove session from sessions to create */
                l_session <-- is_session_to_create (channel_config_idx);
                /* Delete session */
                delete_session (l_session)
            END  
        ELSE
            bres := FALSE
        END
    END
    ;

    bres <-- client_activate_new_session_with_channel (channel_config_idx, channel, user) =
    VAR
        l_session,
        l_valid_session
    IN
        l_session <-- client_init_session;
        l_valid_session <-- is_valid_session (l_session);
        IF l_valid_session = TRUE THEN
            local_create_session (l_session, channel);
            bres <-- add_session_to_activate (l_session, user);
            IF bres = FALSE
            THEN
                /* Remove session from sessions to create */
                l_session <-- is_session_to_create (channel_config_idx);
                /* Delete session */
                delete_session (l_session)
            END
        ELSE
            bres := FALSE
        END
    END
    ;
    
    ret <-- client_activate_session (session, user) =
    BEGIN
        ret <-- local_activate_session (session, user)
    END
    ;
    
    ret <-- client_close_session (session) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_close_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg = TRUE &
            l_valid_msg_header = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN

                ret, l_channel, l_session_token <-- client_close_req (session, l_req_handle, l_req_msg);
                IF ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                    write_msg_out_header_session_token(l_msg_header, l_session_token);
                    l_buffer <-- encode_msg (e_msg_session_close_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = TRUE
                    THEN
                        ret <-- send_channel_msg_buffer (l_channel, l_buffer)
                    ELSE
                        /* allocation / encoding problem */
                        ret := e_sc_nok
                    END;
                    IF ret /= e_sc_ok
                    THEN
                        remove_req_handle (l_req_handle);
                        cli_close_session (session)
                    END
                END
            ELSE
                ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        ELSE
            ret := e_sc_bad_out_of_memory
        END
    END
    ;
    
    ret <-- client_send_service_request_msg (session, req_msg) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_msg_typ,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_valid_msg <-- is_valid_msg_out (req_msg);
        IF l_valid_msg = TRUE
        THEN
            l_msg_typ <-- get_msg_in_type (req_msg);
            CASE l_msg_typ OF
                EITHER e_msg_session_read_req,
                    e_msg_session_write_req
                THEN /* s_service_reqs */
                    l_msg_header <-- alloc_app_req_msg_header (l_msg_typ, req_msg);
                    l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
                    l_req_handle <-- fresh_req_handle;
                    l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                    IF l_valid_req_handle = TRUE &
                        l_valid_msg_header = TRUE
                    THEN
                        bless_msg_out (l_msg_typ, l_msg_header, req_msg);
                        ret, l_channel, l_session_token <-- client_validate_session_service_req (session, l_req_handle,
 req_msg);
                        IF ret = e_sc_ok
                        THEN
                            write_msg_out_header_req_handle (l_msg_header, l_req_handle);
                            write_msg_out_header_session_token (l_msg_header, l_session_token);
                            l_buffer <-- encode_msg (e_msg_session_close_req, l_msg_header, req_msg);
                            l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                            IF l_valid_buffer = TRUE
                            THEN
                                ret <-- send_channel_msg_buffer (l_channel, l_buffer)
                            ELSE
                                /* allocation / encoding problem */
                                ret := e_sc_nok
                            END
                        END
                    ELSE
                        ret := e_sc_bad_out_of_memory
                    END;
                    IF l_valid_msg_header = TRUE
                    THEN
                        dealloc_msg_header_out (l_msg_header)
                    END;
                    dealloc_msg_out (req_msg)
                ELSE
                    ret := e_sc_bad_invalid_argument
                END
            END
        ELSE
            ret := e_sc_bad_invalid_argument
        END
    END
    
END
