/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

REFINEMENT
    address_space_r
REFINES
    address_space

SEES
    constants,
    service_write_decode_bs

DEFINITIONS
    d_variables ==
        a_NodeId,
        a_NodeClass,
        a_BrowseName,
        a_DisplayName,
        a_Value,
        a_Value_StatusCode,

        TypeDefinition,

        Reference_SourceNode,
        Reference_ReferenceType,
        Reference_TargetNode,
        Reference_IsForward,
   
        Node_Reference,
        Node_RefIndexBegin,
        Node_RefIndexEnd,
        RefIndex_Reference,

        /* Service Write */
        ResponseWrite_allocated,
        ResponseWrite_StatusCode
    ;

    d_inv ==
        /* Attributes */
        a_NodeId      : t_Node >-> t_NodeId        &
        a_NodeClass   : t_Node --> t_NodeClass     &
        a_BrowseName  : t_Node --> t_QualifiedName &
        a_DisplayName : t_Node --> t_LocalizedText &

        a_Value : t_Node +-> t_Variant &
        dom(a_NodeClass|>{e_ncl_Variable}) <: dom(a_Value) &
        dom(a_Value) <: dom(a_NodeClass|>{e_ncl_Variable, e_ncl_VariableType}) &

        /* Value attribute meta-data */
        a_Value_StatusCode : t_Node +-> t_StatusCode &
        dom(a_Value_StatusCode) = dom(a_NodeClass|>{e_ncl_Variable}) &

        TypeDefinition : t_Node +-> t_ExpandedNodeId &
        dom(TypeDefinition) = dom(a_NodeClass |> {e_ncl_Variable, e_ncl_Object}) &

        /* References */
        Reference_SourceNode    : t_Reference --> t_NodeId         &
        Reference_ReferenceType : t_Reference --> t_NodeId         &
        Reference_TargetNode    : t_Reference --> t_ExpandedNodeId &
        Reference_IsForward     : t_Reference --> BOOL             &

        Node_Reference          : t_Node     <-> t_Reference &
        Node_RefIndexBegin      : t_Node     --> t_RefIndex  &
        Node_RefIndexEnd        : t_Node     --> t_RefIndex  &
        RefIndex_Reference      : t_RefIndex --> t_Reference &

        /* Service Write */
        ResponseWrite_allocated : BOOL &
        ResponseWrite_StatusCode : t_WriteValue +-> t_StatusCode
    ;

    d_init ==
        d_inv &
        ResponseWrite_allocated = FALSE &
        ResponseWrite_StatusCode = {}
    ;

    /* Relation associating to a node a value which is requested to be written
       in the address space */
    d_a_Value_requested ==
        (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                     WriteValue_NodeId~ ;
         (cast_t_WriteValue[1..nb_WriteValue] /\
          WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_Value)

ABSTRACT_VARIABLES
    d_variables

INITIALISATION
    d_variables :( d_init )

OPERATIONS

    /* --------------------------------------------------------------------- */
    /* Service Write */

    StatusCode_service <-- treat_write_request_WriteValues(userid) =
    BEGIN
        StatusCode_service := e_sc_ok ||
        a_Value,
        ResponseWrite_StatusCode
        :(  ResponseWrite_StatusCode : t_WriteValue +-> t_StatusCode &

            /* For a given node, the write request message may provide different values to be written
               as the value attribute of this node. In this case, the written value is chosen among
               possible values. */

            /* At most one value should be written for each node */
            a_Value : t_Node +-> t_Variant &

            /* Each node with a value requested to be written should indeed be written */
            dom(a_Value) = dom(a_Value$0 <+ d_a_Value_requested) &

            /* The value requested to be written should be contained in the requested values */
            a_Value <: a_Value$0 <+ d_a_Value_requested &

            ResponseWrite_StatusCode = %wvi.(
                wvi : t_WriteValue &
                wvi : cast_t_WriteValue[1..nb_WriteValue]
                |
                {FALSE |-> e_sc_nok,
                 TRUE  |-> e_sc_ok }(bool(wvi : dom(WriteValue_NodeId)              &
                                          wvi : dom(WriteValue_AttributeId)         &
                                          wvi : dom(WriteValue_Value)               &
                                          WriteValue_NodeId(wvi) : ran(a_NodeId)    &
                                          WriteValue_AttributeId(wvi) = e_aid_Value &
                                          a_NodeClass(a_NodeId~(WriteValue_NodeId(wvi))) = e_ncl_Variable))
            )
        )
    END
    ;

    StatusCode_service <-- alloc_write_request_responses(nb_req) =
    BEGIN
        IF nb_req <= k_n_WriteResponse_max THEN
            ResponseWrite_StatusCode,
            ResponseWrite_allocated,
            StatusCode_service
            :(
                ResponseWrite_allocated  : BOOL                          &
                ResponseWrite_StatusCode : t_WriteValue +-> t_StatusCode &
                StatusCode_service       : t_StatusCode_i                &
                (ResponseWrite_allocated = TRUE
                 =>
                 ResponseWrite_StatusCode = cast_t_WriteValue[1..nb_req] * {e_sc_nok} &
                 StatusCode_service = e_sc_ok) &
                (ResponseWrite_allocated = FALSE
                 =>
                 ResponseWrite_StatusCode = {} &
                 StatusCode_service = e_sc_nok)
            )
        ELSE
            ResponseWrite_allocated := FALSE ||
            StatusCode_service      := e_sc_nok
        END
    END

END
