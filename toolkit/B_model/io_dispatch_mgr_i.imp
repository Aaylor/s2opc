/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION io_dispatch_mgr_i
REFINES io_dispatch_mgr

SEES
    constants

IMPORTS
    session_mgr,
    session_async_bs,
    message_in_bs,
    message_out_bs,
    service_read,
    channel_mgr_bs,
    request_handle_bs,
    service_response_cli_cb_bs,
    address_space,
    service_write_decode_bs

PROMOTES
    get_session_state_or_closed

LOCAL_OPERATIONS

    resp_msg_typ <-- get_response_type (req_msg_typ) =
    PRE
        req_msg_typ : t_msg_type &
        req_msg_typ : s_req_msgs
    THEN
       resp_msg_typ :(resp_msg_typ : t_msg_type &
                      resp_msg_typ : s_resp_msgs)
    END
    ;

    bres <-- is_request_type (msg_typ) =
    PRE
        msg_typ : t_msg_type
    THEN
        bres :: BOOL
    END
    ;

    treat_read_request(p_request_msg, p_response_msg) =
    PRE
        p_request_msg  : t_msg_i   &
        p_request_msg  = c_msg_in  &
        p_response_msg : t_msg_i   &
        p_response_msg = c_msg_out
    THEN
        nb_ReadValue,
        ReadValue_NodeId,
        ReadValue_AttributeId,
        data_Value_Value,
        data_Value_StatusCode
        :(
          nb_ReadValue          : NAT                           &
          nb_ReadValue         <= k_n_read_resp_max             &
          ReadValue_NodeId      : t_ReadValue +-> t_NodeId      &
          ReadValue_AttributeId : t_ReadValue +-> t_AttributeId &
          data_Value_Value      : t_ReadValue +-> t_Variant     &
          data_Value_StatusCode : t_ReadValue +-> t_StatusCode
         )
    END
    ;
    
    /* TODO: call the treat write on an encoded WriteRequest */
    /* TODO: add constraints on userid? */
    StatusCode_service <-- treat_write_request(req_payload, userid) =
    PRE
        req_payload : t_ByteString_i &
        req_payload : t_ByteString &
        userid : t_user_i &
        userid : t_user
    THEN
        StatusCode_service
        :(  StatusCode_service : t_StatusCode_i &
            StatusCode_service : t_StatusCode
        )
    END
	;

    local_create_session (session, channel) =
    PRE
        session : t_session_i &
        session : t_session &
        channel : t_channel_i &
        channel : t_channel &
        c_msg_out = c_msg_indet
    THEN
        skip
    END
    ;
    
    local_sc_activate_orphaned_sessions (channel_config_idx, channel) =
    PRE
        channel : t_channel_i &
        channel : t_channel &
        channel_config_idx : t_channel_config_idx_i &
        channel_config_idx : t_channel_config_idx
    THEN
        skip
    END
    ;
    
    ret <-- local_activate_session (session, user) =
    PRE
        session : t_session_i &
        session : t_session &
        user : t_user_i &
        user : t_user &
        c_msg_out = c_msg_indet
    THEN
        ret :: {e_sc_ok, 
            e_sc_bad_out_of_memory,
            e_sc_bad_invalid_argument,
            e_sc_bad_invalid_state,          /* session not in a valid state to activate a user on it */
            e_sc_bad_unexpected_error,
            e_sc_bad_identity_token_invalid, /* user identity invalid */
            e_sc_bad_encoding_error,
            e_sc_bad_secure_channel_closed,
            e_sc_bad_connection_closed,
            e_sc_bad_encoding_error}
    END
    

OPERATIONS

    resp_msg_typ <-- get_response_type (req_msg_typ) =
    BEGIN
        CASE req_msg_typ OF
            EITHER e_msg_public_service_req THEN
                resp_msg_typ := e_msg_public_service_resp
            OR e_msg_session_create_req THEN
                resp_msg_typ := e_msg_session_create_resp
            OR e_msg_session_activate_req THEN
                resp_msg_typ := e_msg_session_activate_resp
            OR e_msg_session_close_req THEN
                resp_msg_typ := e_msg_session_close_resp
            OR e_msg_session_read_req THEN
                resp_msg_typ := e_msg_session_read_resp
            OR e_msg_session_write_resp THEN
                resp_msg_typ := e_msg_session_write_resp
            END
        END
    END
    ;

    bres <-- is_request_type (msg_typ) =
    BEGIN
        CASE msg_typ OF
            EITHER e_msg_public_service_req,
                e_msg_session_create_req,
                e_msg_session_activate_req,
                e_msg_session_close_req,
                e_msg_session_read_req,
                e_msg_session_write_req
            THEN
                bres := TRUE
            ELSE

                bres := FALSE
            END
        END
    END
    ;

    treat_read_request(p_request_msg, p_response_msg) =
    VAR
        l_nb_ReadValue,
        l_is_valid
    IN
        l_is_valid, l_nb_ReadValue <-- check_ReadRequest(p_request_msg);
        IF  l_is_valid = TRUE THEN
            l_is_valid <-- alloc_read_response(l_nb_ReadValue, p_response_msg);
            IF  l_is_valid = TRUE THEN
                fill_read_response(p_request_msg, p_response_msg)
            END
        END
    END
    ;

    StatusCode_service <-- treat_write_request(req_payload, userid) =
    VAR
        l_nb_req
    IN
        StatusCode_service <-- decode_write_request(req_payload);
        IF StatusCode_service = e_sc_ok
        THEN
            l_nb_req <-- get_nb_WriteValue;
            StatusCode_service <-- alloc_write_request_responses(l_nb_req);
            IF StatusCode_service = e_sc_ok
            THEN
                StatusCode_service <-- treat_write_request_WriteValues(userid)
            END
        END;
        free_write_request
    END
    ;
    
    local_create_session (session, channel) =
    VAR
        l_req_msg,
        l_req_handle,
        l_valid_req_handle,
        l_valid_msg,
        l_valid_session,
        l_ret
    IN
        l_req_msg <-- alloc_req_msg (e_msg_session_create_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        IF l_valid_msg = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle  = TRUE
            THEN
                l_valid_session <-- is_valid_session (session);
                IF l_valid_session = TRUE
                THEN
                    l_ret <-- cli_create_req (session, channel, l_req_handle, l_req_msg);
                    IF l_ret = e_sc_ok
                    THEN
                        
                        write_msg_out_header_req_handle (l_req_msg, l_req_handle);
                        l_ret <-- send_channel_msg (channel, l_req_msg);
                        IF l_ret /= e_sc_ok
                        THEN
                            remove_req_handle (l_req_handle);
                            cli_close_session (session)
                        END
                    ELSE
                        remove_req_handle (l_req_handle);
                        cli_close_session (session)
                    END
                ELSE
                    cli_close_session (session)
                END
            END;
            dealloc_msg_out (l_req_msg)
        END
    END
    ;
    
    local_sc_activate_orphaned_sessions (channel_config_idx, channel) =
    VAR
        l_valid_new_channel,
        l_req_msg,
        l_valid_msg,
        l_continue,
        l_session,
        l_ret,
        l_req_handle,
        l_valid_req_handle,
        l_session_token
    IN
        l_valid_new_channel <-- is_connected_channel (channel);
        IF l_valid_new_channel = TRUE
        THEN
            l_continue <-- init_iter_orphaned_t_session (channel_config_idx);
            WHILE l_continue = TRUE
            DO
                l_session, l_continue <-- continue_iter_orphaned_t_session;
                l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
                l_valid_msg <-- is_valid_msg_out (l_req_msg);
                IF l_valid_msg = TRUE
                THEN
                    l_req_handle <-- fresh_req_handle;
                    l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                    IF l_valid_req_handle = TRUE
                    THEN
                        l_ret, l_session_token <-- cli_sc_activate_req (l_session, l_req_handle, channel, l_req_msg);
                        IF l_ret = e_sc_ok
                        THEN
                            write_msg_out_header_req_handle(l_req_msg, l_req_handle);
                            write_msg_out_header_session_token(l_req_msg, l_session_token);
                            l_ret <-- send_channel_msg (channel, l_req_msg);
                            /* TODO: something in case of failure ? */
                            IF l_ret /= e_sc_ok
                            THEN
                                remove_req_handle (l_req_handle);
                                cli_close_session (l_session)
                            END
                        END
                    END;
                    dealloc_msg_out (l_req_msg)
                END
            INVARIANT
                l_continue = bool(av_sessions_to_iterate /= {}) &
                av_sessions_to_iterate /\ av_sessions_iterated = {} &
                av_sessions_to_iterate \/ av_sessions_iterated = av_sessions_orphaned
            VARIANT
                card(av_sessions_to_iterate)
            END
        END
    END
    ;
    
    ret <-- local_activate_session (session, user) =
    VAR
        l_req_msg,
        l_valid_msg,
        l_ret,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token
    IN
        l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        IF l_valid_msg = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN
                l_req_handle <-- fresh_req_handle;
                l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                IF l_valid_req_handle = TRUE
                THEN
                    l_ret, l_channel, l_session_token <-- cli_user_activate_req (session, l_req_handle, user, l_req_msg);
                    IF l_ret = e_sc_ok
                    THEN
                        write_msg_out_header_req_handle(l_req_msg, l_req_handle);
                        write_msg_out_header_session_token(l_req_msg, l_session_token);
                        l_ret <-- send_channel_msg (l_channel, l_req_msg);
                        IF l_ret /= e_sc_ok
                        THEN
                            remove_req_handle (l_req_handle);
                            cli_close_session (session)
                        END
                    END
                ELSE
                    l_ret := e_sc_bad_out_of_memory
                END
            ELSE
                l_ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_out (l_req_msg)
        ELSE
            l_ret := e_sc_bad_out_of_memory
        END;
        ret := l_ret
    END
    ;
    
    /* END OF LOCAL OPERATIONS */

    msgs_memory_changed =
    BEGIN
        msg_in_memory_changed;
        msg_out_memory_changed
    END
    ;

    receive_msg (channel, msg) =
    VAR
        l_request_handle,
        l_session_token,
        l_session,
        l_session_state,
        l_session_user,
        l_valid_msg,
        l_msg_type,
        l_payload,
        l_connected_channel,
        l_is_client,
        l_is_req,
        l_is_valid_req,
        l_snd_session_err,
        l_is_valid_resp,
        l_status,
        l_resp_msg_typ,
        l_resp_msg,
        l_to_send,
        l_ret
    IN
        l_connected_channel <-- is_connected_channel (channel);
        l_valid_msg <-- is_valid_msg_in (msg);
        IF l_connected_channel = TRUE &
            l_valid_msg = TRUE
        THEN
            l_msg_type <-- get_msg_in_type (msg);
            CASE l_msg_type OF
                EITHER 
                    e_msg_public_service_req, e_msg_public_service_resp
                THEN
                    /* TODO: no public service treated for now */
                    skip
                ELSE
                    l_is_client <-- is_client_channel (channel);
                    l_is_req <-- is_request_type (l_msg_type);

                    IF l_is_client = TRUE & l_is_req = FALSE
                    THEN

                        /* client treatment */
                        CASE l_msg_type OF
                            EITHER e_msg_session_create_resp,
                                e_msg_session_activate_resp,
                                e_msg_session_close_resp
                            THEN
                                l_request_handle <-- read_msg_header_req_handle (msg);
                                l_session <-- receive_session_resp (channel, l_request_handle, msg, l_msg_type);
                                remove_req_handle (l_request_handle);
                                
                                // If session is created, activate it with async data if present
                                l_session_state <-- get_session_state_or_closed (l_session);
                                IF l_session_state = e_session_created 
                                THEN
                                    l_session_user <-- is_session_to_activate (l_session);
                                    IF l_session_user /= c_user_indet
                                    THEN
                                        l_ret <-- local_activate_session (l_session, l_session_user)
                                    END
                                END;
                                // In case it is an internally treated message we have to deallocate it
                                // (services response messages are forwarded to application)
                                dealloc_msg_in (msg)
                                
                            OR e_msg_session_read_resp,
                                e_msg_session_write_resp
                            THEN
                                l_request_handle <-- read_msg_header_req_handle (msg);
                                l_is_valid_resp <-- cli_validate_session_service_resp (channel, l_request_handle, msg);
                                IF l_is_valid_resp = TRUE
                                THEN
                                    l_status <-- read_msg_resp_header_service_status (msg);
                                    cli_service_response (msg, l_status)
                                END
                            END
                        END
                    ELSIF l_is_client = FALSE & l_is_req = TRUE
                    THEN
                        /* server treatment */
                        CASE l_msg_type OF
                            EITHER e_msg_session_create_req,
                                e_msg_session_activate_req,
                                e_msg_session_close_req
                            THEN
                                l_request_handle <-- read_msg_header_req_handle (msg);
                                l_session_token <-- read_msg_req_header_session_token (msg);
                                l_resp_msg_typ <-- get_response_type (l_msg_type);
                                l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ, msg);
                                l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                                IF l_valid_msg = TRUE
                                THEN
                                    /* TODO: ret value to guarantee session is valid */
                                    l_to_send, l_session <-- receive_session_req (channel, l_request_handle, l_session_token, msg, l_msg_type, l_resp_msg);
                                    IF l_to_send = TRUE
                                    THEN
                                        write_msg_out_header_req_handle (l_resp_msg, l_request_handle);
                                        l_ret <-- send_channel_msg (channel, l_resp_msg);
                                        IF l_ret /= e_sc_ok
                                        THEN
                                            cli_close_session (l_session)
                                        END
                                    END;
                                    dealloc_msg_out (l_resp_msg)
                                END
                            OR e_msg_session_read_req,
                                e_msg_session_write_req
                            THEN
                                l_request_handle <-- read_msg_header_req_handle (msg);
                                l_session_token <-- read_msg_req_header_session_token (msg);
                                l_is_valid_req, l_snd_session_err <-- srv_validate_session_service_req (channel, l_request_handle, l_session_token, msg);
                                IF l_is_valid_req = TRUE
                                THEN
                                    l_resp_msg_typ <-- get_response_type (l_msg_type);
                                    l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ, msg);
                                    l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                                    l_session <-- get_session_from_token (l_session_token);
                                    IF l_valid_msg = TRUE
                                    THEN
                                        CASE l_msg_type OF
                                            EITHER e_msg_session_read_req THEN
                                                treat_read_request (msg, l_resp_msg)
                                            OR e_msg_session_write_req THEN
                                                // Write request case
                                                l_session_user <-- get_session_user_or_indet (l_session);
                                                l_payload <-- get_msg_payload (msg);
                                                l_ret <-- treat_write_request (l_payload, l_session_user);
                                                /* TODO: where should the service StatusCode be written ?? */
                                                /* TODO: the following may fail (malloc) */
                                                write_WriteResponse_msg_out(l_resp_msg);
                                                dealloc_write_request_responses
                                            END
                                        END;
                                        l_is_valid_resp, l_snd_session_err <-- srv_validate_session_service_resp (channel, l_session, l_request_handle, msg, l_resp_msg);
                                        IF l_is_valid_resp = TRUE THEN
                                            write_msg_out_header_req_handle (l_resp_msg, l_request_handle);
                                            l_ret <-- send_channel_msg (channel, l_resp_msg)
                                        END;
                                        dealloc_msg_out (l_resp_msg)
                                    END
                                    // TODO log error if any
                                END;
                                IF l_snd_session_err = TRUE
                                THEN
                                    /* Send a session closed error in response */
                                    l_resp_msg_typ <-- get_response_type (l_msg_type);
                                    l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ, msg);
                                    l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                                    IF l_valid_msg = TRUE
                                    THEN
                                        write_msg_out_header_req_handle (l_resp_msg, l_request_handle);
                                        write_msg_resp_header_service_status (l_resp_msg, e_sc_bad_session_closed);
                                        l_ret <-- send_channel_msg (channel, l_resp_msg);
                                        dealloc_msg_out (l_resp_msg)
                                    END
                                END
                            END
                        END;
                        // In case it is an internally treated message we have to deallocate it
                        // (all messages received by server are treated internally)
                        dealloc_msg_in (msg)
                    ELSE
                        skip /* Not a request on a server channel NOR a response on a client channel */
                    END
                END
            END
        END
    END
    ;
    
        
    cli_channel_connected_event (channel_config_idx, channel) =
    VAR
        l_session_to_create,
        l_bres
    IN
        l_bres <-- cli_set_connected_channel (channel_config_idx, channel);
        IF l_bres = TRUE
        THEN
            // Re-associate orphaned sessions waiting for sc (if there are some)
            local_sc_activate_orphaned_sessions (channel_config_idx, channel);
            // Create session waiting for sc
            l_session_to_create <-- is_session_to_create (channel_config_idx);
            IF l_session_to_create /= c_session_indet
            THEN
                local_create_session (l_session_to_create, channel)
                // activation already registered as next async step
            END
        END
    END
    ;
    
    srv_channel_connected_event (endpoint_config_idx, channel_config_idx, channel) =
    VAR
        l_bres
    IN
        l_bres <-- srv_new_secure_channel (endpoint_config_idx, channel_config_idx, channel)
    END
    ;
    
    session <-- activate_new_session (channel_config_idx, user) =
    VAR
        l_channel,
        l_channel_connected,
        l_valid_session,
        l_connected_channel,
        l_bret
    IN
        session := c_session_indet;
        l_channel <-- get_connected_channel (channel_config_idx);
        l_connected_channel <-- is_connected_channel (l_channel);
        IF l_connected_channel = FALSE
        THEN
            l_bret <-- cli_open_secure_channel (channel_config_idx);
            l_channel_connected := FALSE
        ELSE
            l_bret := TRUE;
            l_channel_connected := TRUE
        END;

        IF l_bret = TRUE
        THEN
            session <-- cli_init_session;
            l_valid_session <-- is_valid_session (session);
            IF l_valid_session = TRUE THEN
                IF l_channel_connected = FALSE 
                THEN
                    /* channel did not exist or is not connected anymore: add async session creation on SC connection */
                    l_bret <-- add_session_to_create (session, channel_config_idx)
                ELSE
                    // l_channel defined because l_channel_connected = TRUE 
                    local_create_session (session, l_channel);
                    l_bret := TRUE
                END;
                IF l_bret = TRUE
                THEN
                    l_bret <-- add_session_to_activate (session, user)
                END;
                IF l_bret = FALSE
                THEN
                    /* Remove session from sessions to create */
                    session <-- is_session_to_create (channel_config_idx);
                    /* Delete session */
                    delete_session (session);
                    session := c_session_indet
                END            
            END
        END
    END
    ;

    ret <-- activate_session (session, user) =
    BEGIN
        ret <-- local_activate_session (session, user)
    END
    ;


    ret <-- close_session (session) =
    VAR
        l_req_msg,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token
    IN
        l_req_msg <-- alloc_req_msg (e_msg_session_close_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        IF l_valid_msg = TRUE
        THEN
            l_req_handle <-- fresh_req_handle;
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN

                ret, l_channel, l_session_token <-- cli_close_req (session, l_req_handle, l_req_msg);
                IF ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_req_msg, l_req_handle);
                    write_msg_out_header_session_token(l_req_msg, l_session_token);
                    ret <-- send_channel_msg (l_channel, l_req_msg);
                    IF ret /= e_sc_ok
                    THEN
                        remove_req_handle (l_req_handle);
                        cli_close_session (session)
                    END
                END
            ELSE
                ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_out (l_req_msg)
        ELSE
            ret := e_sc_bad_out_of_memory
        END
    END
    ;


    secure_channel_lost (channel) =
    VAR
        l_connected_channel,
        l_valid_new_channel,
        l_is_client,
        l_channel_config_idx,
        l_new_channel,
        l_bres
    IN
        l_connected_channel <-- is_connected_channel (channel);
        IF l_connected_channel = TRUE
        THEN
            l_is_client <-- is_client_channel (channel);
            IF l_is_client = TRUE
            THEN
                l_channel_config_idx <-- get_channel_info (channel);
                cli_secure_channel_lost (channel, l_channel_config_idx);
                l_new_channel <-- get_connected_channel (l_channel_config_idx);
                IF l_new_channel = c_channel_indet
                THEN
                    l_bres <-- cli_open_secure_channel (l_channel_config_idx)
                    // async operation => cannot use channel until connection is effective ?
                END;
               	
                l_valid_new_channel <-- is_connected_channel (l_new_channel);
                
                IF l_valid_new_channel = TRUE
                THEN
                    // If channel already connected, associate sessions orphaned
                    local_sc_activate_orphaned_sessions (l_channel_config_idx, l_new_channel)                    
                END
            ELSE
                srv_secure_channel_lost (channel)
            END;
            channel_lost (channel)
        END
    END
    ;


    ret <-- send_service_request_msg (session, req_msg) =
    VAR
        l_msg_typ,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token
    IN
        l_msg_typ <-- get_msg_in_type (req_msg);
        CASE l_msg_typ OF
            EITHER e_msg_session_read_req,
                e_msg_session_write_req
            THEN /* s_service_reqs */
                bless_msg_out (req_msg, l_msg_typ);
                l_valid_msg <-- is_valid_msg_out (req_msg);
                IF l_valid_msg = TRUE
                THEN
                    l_req_handle <-- fresh_req_handle;
                    l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                    IF l_valid_req_handle = TRUE
                    THEN
                        ret, l_channel, l_session_token <-- cli_validate_session_service_req (session, l_req_handle, req_msg);
                        IF ret = e_sc_ok
                        THEN
                            write_msg_out_header_req_handle (req_msg, l_req_handle);
                            write_msg_out_header_session_token (req_msg, l_session_token);
                            ret <-- send_channel_msg (l_channel, req_msg)
                        END
                    ELSE
                        ret := e_sc_bad_out_of_memory
                    END
                ELSE
                    ret := e_sc_bad_invalid_argument
                END
                /* TODO: deallocate request ? unprovable PO without it */
                // dealloc_msg_out (req_msg)
            ELSE
                ret := e_sc_bad_invalid_argument
            END
        END
    END;


    close_all_active_connections =
    BEGIN
        close_all_channel
    END

END
