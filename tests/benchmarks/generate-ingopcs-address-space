#!/usr/bin/env python3

# Copyright (C) 2018 Systerel and others.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Something faster than XSLT to generate a C address space from an OPC UA nodeset.

import argparse
import base64
import sys
import uuid
from xml.etree.ElementTree import iterparse, Element

UA_NODESET_NS = '{http://opcfoundation.org/UA/2011/03/UANodeSet.xsd}'
UA_NODESET_TAG = UA_NODESET_NS + 'UANodeSet'
UA_ALIASES_TAG = UA_NODESET_NS + 'Aliases'
UA_ALIAS_TAG = UA_NODESET_NS + 'Alias'
UA_VIEW_TAG = UA_NODESET_NS + 'UAView'
UA_OBJECT_TAG = UA_NODESET_NS + 'UAObject'
UA_VARIABLE_TAG = UA_NODESET_NS + 'UAVariable'
UA_VARIABLE_TYPE_TAG = UA_NODESET_NS + 'UAVariableType'
UA_OBJECT_TYPE_TAG = UA_NODESET_NS + 'UAObjectType'
UA_REFERENCE_TYPE_TAG = UA_NODESET_NS + 'UAReferenceType'
UA_DATA_TYPE_TAG = UA_NODESET_NS + 'UADataType'
UA_METHOD_TAG = UA_NODESET_NS + 'UAMethod'
UA_DESCRIPTION_TAG = UA_NODESET_NS + 'Description'
UA_DISPLAY_NAME_TAG = UA_NODESET_NS + 'DisplayName'
UA_REFERENCES_TAG = UA_NODESET_NS + 'References'
UA_REFERENCE_TAG = UA_NODESET_NS + 'Reference'
UA_VALUE_TAG = UA_NODESET_NS + 'Value'

ID_TYPE_NUMERIC = 0
ID_TYPE_STRING = 1
ID_TYPE_GUID = 2
ID_TYPE_BYTESTRING = 3

UA_TYPES_NS = '{http://opcfoundation.org/UA/2008/02/Types.xsd}'

UA_VALUE_TYPE_BOOL = UA_TYPES_NS + 'Boolean'
UA_VALUE_TYPE_BYTE = UA_TYPES_NS + 'Byte'
UA_VALUE_TYPE_INT16 = UA_TYPES_NS + 'Int16'
UA_VALUE_TYPE_INT32 = UA_TYPES_NS + 'Int32'
UA_VALUE_TYPE_INT64 = UA_TYPES_NS + 'Int64'
UA_VALUE_TYPE_GUID = UA_TYPES_NS + 'Guid'
UA_VALUE_TYPE_NODEID = UA_TYPES_NS + 'NodeId'
UA_VALUE_TYPE_SBYTE = UA_TYPES_NS + 'SByte'
UA_VALUE_TYPE_UINT16 = UA_TYPES_NS + 'UInt16'
UA_VALUE_TYPE_UINT32 = UA_TYPES_NS + 'UInt32'
UA_VALUE_TYPE_UINT64 = UA_TYPES_NS + 'UInt64'
UA_VALUE_TYPE_FLOAT = UA_TYPES_NS + 'Float'
UA_VALUE_TYPE_DOUBLE = UA_TYPES_NS + 'Double'
UA_VALUE_TYPE_STRING = UA_TYPES_NS + 'String'
UA_VALUE_TYPE_BYTESTRING = UA_TYPES_NS + 'ByteString'
UA_VALUE_TYPE_XMLELEMENT = UA_TYPES_NS + 'XmlElement'
UA_VALUE_TYPE_DATETIME = UA_TYPES_NS + 'DateTime'

VALUE_TYPE_BOOL = 0
VALUE_TYPE_BYTE = 1
VALUE_TYPE_INT16 = 2
VALUE_TYPE_INT32 = 3
VALUE_TYPE_INT64 = 4
VALUE_TYPE_GUID = 5
VALUE_TYPE_NODEID = 6
VALUE_TYPE_SBYTE = 7
VALUE_TYPE_UINT16 = 8
VALUE_TYPE_UINT32 = 9
VALUE_TYPE_UINT64 = 10
VALUE_TYPE_FLOAT = 11
VALUE_TYPE_DOUBLE = 12
VALUE_TYPE_STRING = 13
VALUE_TYPE_BYTESTRING = 14
VALUE_TYPE_XMLELEMENT = 15
VALUE_TYPE_DATETIME = 16

C_IDENTIFIER_TYPES = [
    'SOPC_IdentifierType_Numeric',
    'SOPC_IdentifierType_String',
    'SOPC_IdentifierType_Guid',
    'SOPC_IdentifierType_ByteString'
]

NODE_CLASS_VIEW = 0
NODE_CLASS_OBJECT = 1
NODE_CLASS_VARIABLE = 2
NODE_CLASS_VARIABLE_TYPE = 3
NODE_CLASS_OBJECT_TYPE = 4
NODE_CLASS_REFERENCE_TYPE = 5
NODE_CLASS_DATA_TYPE = 6
NODE_CLASS_METHOD = 7
NODE_CLASS_EXTERNAL = -1  # Used for external references, not in the "normal" node classes

NODE_CLASSES = [
    NODE_CLASS_VIEW,
    NODE_CLASS_OBJECT,
    NODE_CLASS_VARIABLE,
    NODE_CLASS_VARIABLE_TYPE,
    NODE_CLASS_OBJECT_TYPE,
    NODE_CLASS_REFERENCE_TYPE,
    NODE_CLASS_DATA_TYPE,
    NODE_CLASS_METHOD
]

c_header = '''
/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "sopc_address_space.h"

#include <stdio.h>
#include <stdbool.h>

#include "opcua_statuscodes.h"

#include "sopc_toolkit_constants.h"
#include "sopc_builtintypes.h"
#include "sopc_types.h"

'''.lstrip()

c_footer = '''
SOPC_AddressSpace addressSpace = {
    .nbVariables = NB_VARIABLES,
    .nbVariableTypes = NB_VARIABLE_TYPES,
    .nbObjectTypes = NB_OBJECT_TYPES,
    .nbReferenceTypes = NB_REFERENCE_TYPES,
    .nbDataTypes = NB_DATA_TYPES,
    .nbMethods = NB_METHODS,
    .nbObjects = NB_OBJECTS,
    .nbViews = NB_VIEWS,
    .nbNodesTotal = NB,

    .browseNameArray = BrowseName,
    .descriptionIdxArray_begin = Description_begin,
    .descriptionIdxArray_end = Description_end,
    .descriptionArray = Description,
    .displayNameIdxArray_begin = DisplayName_begin,
    .displayNameIdxArray_end = DisplayName_end,
    .displayNameArray = DisplayName,
    .nodeClassArray = NodeClass,
    .nodeIdArray = NodeId,
    .referenceIdxArray_begin = reference_begin,
    .referenceIdxArray_end = reference_end,
    .referenceTypeArray = reference_type,
    .referenceTargetArray = reference_target,
    .referenceIsForwardArray = reference_isForward,
    .valueArray = Value,
    .valueStatusArray = status_code,
    .accessLevelArray = AccessLevel,
};
'''.lstrip()


class ParseError(Exception):
    """
    Errors raised during XML parsing
    """
    pass


class ResolveError(Exception):
    """
    Errors raised during name resolution
    """
    pass


class CodeGenerationError(Exception):
    """
    Errors raised during C code generation
    """
    pass


class NodeId(object):
    __slots__ = 'ns', 'ty', 'data'

    def __init__(self, ns, ty, data):
        self.ns = ns
        self.ty = ty
        self.data = data

    def __str__(self):
        s = ('ns=%d;' % self.ns) if self.ns else ''

        if self.ty == ID_TYPE_NUMERIC:
            s += ('i=%d' % self.data)
        elif self.ty == ID_TYPE_STRING:
            s += ('s=%s' % self.data)
        elif self.ty == ID_TYPE_GUID:
            s += ('g=%s' % str(self.data))
        elif self.ty == ID_TYPE_BYTESTRING:
            s += ('b=%s' % base64.standard_b64encode(self.data))

        return s

    @staticmethod
    def parse(nodeid):
        ty = None
        data = None
        cur = nodeid

        # Parse namespace
        if nodeid.startswith('ns='):
            ns_end_idx = nodeid.find(';')

            if ns_end_idx == -1:
                raise ParseError('Invalid NodeId: ' + nodeid)

            try:
                ns = int(nodeid[3:ns_end_idx])
            except ValueError:
                raise ParseError('Non integer namespace in NodeId: ' + nodeid)

            cur = cur[ns_end_idx+1:]
        else:
            ns = None

        if len(cur) < 3:
            raise ParseError('Truncated NodeId: ' + nodeid)

        if cur[0] == 'i':
            ty = ID_TYPE_NUMERIC

            try:
                data = int(cur[2:])
            except ValueError:
                raise ParseError('Invalid numeric NodeId: ' + nodeid)
        elif cur[0] == 's':
            ty = ID_TYPE_STRING
            data = cur[2:]
        elif cur[0] == 'g':
            ty = ID_TYPE_GUID

            try:
                data = uuid.UUID(cur[2:])
            except ValueError:
                raise ParseError('Invalid GUID NodeId: ' + nodeid)
        elif cur[0] == 'b':
            ty = ID_TYPE_BYTESTRING

            try:
                data = base64.standard_b64decode(cur[2:])
            except TypeError:
                raise ParseError('Invalid bytestring NodeId: ' + nodeid)

        return NodeId(ns, ty, data)


class QName(object):
    __slots__ = 'ns', 'name'

    def __init__(self, ns, name):
        self.ns = ns
        self.name = name

    @staticmethod
    def parse(qname):
        idx = qname.find(':')

        if idx == -1:
            return QName(None, qname)

        try:
            ns = int(qname[0:idx])
        except ValueError:
            raise ParseError('Invalid namespace in qualified name: ' + qname)

        name = qname[1+idx:]

        if not name:
            raise ParseError('Missing name in qualified name: ' + qname)

        return QName(ns, name)


class LocalizedText(object):
    __slots__ = 'locale', 'text'

    def __init__(self, locale, text):
        self.locale = locale
        self.text = text


class VariableValue(object):
    __slots__ = 'ty', 'val'

    def __init__(self, ty, val):
        self.ty = ty
        self.val = val


class Node(object):
    __slots__ = 'idx', 'nodeclass', 'nodeid', 'browse_name', 'description', 'display_name', 'references',\
                'idonly', 'value', 'accesslevel'

    def __init__(self, idx, nodeclass, nodeid, browse_name, description, display_name, references):
        self.idx = idx
        self.nodeclass = nodeclass
        self.nodeid = nodeid
        self.browse_name = browse_name
        self.description = description
        self.display_name = display_name
        self.references = references
        self.idonly = False
        self.value = None
        self.accesslevel = None

    @staticmethod
    def make_idonly(nodeid):
        n = Node(None, None, nodeid, None, None, None, None)
        n.idonly = True
        return n


class Reference(object):
    __slots__ = 'ty', 'target', 'is_forward'

    def __init__(self, ty, target, is_forward):
        self.ty = ty
        self.target = target
        self.is_forward = is_forward


def expect_element(source, name=None):
    ev, n = next(source)

    if ev != 'start':
        n.clear()
        raise ParseError('Expected element start, got ' + ev)

    return check_element(n, name)


def check_element(n, name=None):
    if not isinstance(n, Element):
        n.clear()
        raise ParseError('Expected element, got %s' % str(n))

    if name is not None and n.tag != name:
        n.clear()
        raise ParseError('Expected element %s, got %s' % (name, str(n)))

    return n


def skip_element(source, name):
    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while skipping to end of ' + name)

        finished = (ev == 'end' and isinstance(n, Element) and n.tag == name)
        n.clear()

        if finished:
            return


def parse_element(source, name):
    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while parsing to end of ' + name)

        if ev == 'end' and isinstance(n, Element) and n.tag == name:
            return


def collect_aliases(node):
    aliases = {}

    for n in node.findall(UA_ALIAS_TAG):
        try:
            name = n.attrib['Alias']
        except KeyError:
            raise ParseError('Missing Alias for alias ' + n.text)

        aliases[name] = n.text

    return aliases


def localized_text_of_child(node, name):
    child = node.find(name)

    if child is None:
        return None

    return LocalizedText(child.get('Locale'), child.text)


def collect_node_references(node, aliases):
    refs = []

    refs_node = node.find(UA_REFERENCES_TAG)

    if refs_node is None:
        return refs

    for n in refs_node.findall(UA_REFERENCE_TAG):
        try:
            ref_type = n.attrib['ReferenceType']
        except KeyError:
            raise ParseError('Missing ReferenceType on Reference element for node ' + node.get('NodeId'))

        # In case there is an alias, resolve it
        ref_type = aliases.get(ref_type, ref_type)

        is_forward = (n.get('IsForward', 'true') == 'true')

        refs.append(Reference(ref_type, n.text, is_forward))

    return refs


# Returns a VariableValue object
def collect_variable_value(n):
    value_node = n.find(UA_VALUE_TAG)

    if value_node is None:
        # print('No Value tag in Variable or VariableType for node %s' % n.attrib['NodeId'])
        return None

    if len(value_node) != 1:
        raise ParseError('Value tag should have exactly one children')

    value = list(value_node)[0]

    if value.tag == UA_VALUE_TYPE_BOOL:
        ty = VALUE_TYPE_BOOL
        val = (value.text == 'true')
    elif value.tag == UA_VALUE_TYPE_BYTE:
        ty = VALUE_TYPE_BYTE
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_INT16:
        ty = VALUE_TYPE_INT16
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_INT32:
        ty = VALUE_TYPE_INT32
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_INT64:
        ty = VALUE_TYPE_INT32
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_GUID:
        ty = VALUE_TYPE_GUID
        val = value.text
    elif value.tag == UA_VALUE_TYPE_NODEID:
        ty = VALUE_TYPE_NODEID
        val = value.text
    elif value.tag == UA_VALUE_TYPE_SBYTE:
        ty = VALUE_TYPE_SBYTE
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_UINT16:
        ty = VALUE_TYPE_UINT16
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_UINT32:
        ty = VALUE_TYPE_UINT32
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_UINT64:
        ty = VALUE_TYPE_UINT64
        val = int(value.text)
    elif value.tag == UA_VALUE_TYPE_FLOAT:
        ty = VALUE_TYPE_FLOAT
        val = float(value.text)
    elif value.tag == UA_VALUE_TYPE_DOUBLE:
        ty = VALUE_TYPE_DOUBLE
        val = float(value.text)
    elif value.tag == UA_VALUE_TYPE_STRING:
        ty = VALUE_TYPE_STRING
        val = value.text
    elif value.tag == UA_VALUE_TYPE_BYTESTRING:
        ty = VALUE_TYPE_BYTESTRING
        val = value.text
    elif value.tag == UA_VALUE_TYPE_XMLELEMENT:
        ty = VALUE_TYPE_XMLELEMENT
        val = value.text
    elif value.tag == UA_VALUE_TYPE_DATETIME:
        ty = VALUE_TYPE_DATETIME
        val = value.text
    else:
        raise ParseError('Unknown value type %s for node %s' % (value.tag, n.attrib['NodeId']))

    return VariableValue(ty, val)


# Returns an array of Node objects
def parse_address_space(source, parse_values=True):
    nodes = []
    aliases = {}

    expect_element(source, UA_NODESET_TAG).clear()

    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while parsing UANodeSet')

        if ev == 'end' and n.tag == UA_NODESET_TAG:
            return nodes

        check_element(n)

        node_class = None

        if n.tag == UA_VIEW_TAG:
            node_class = NODE_CLASS_VIEW
        elif n.tag == UA_OBJECT_TAG:
            node_class = NODE_CLASS_OBJECT
        elif n.tag == UA_VARIABLE_TAG:
            node_class = NODE_CLASS_VARIABLE
        elif n.tag == UA_VARIABLE_TYPE_TAG:
            node_class = NODE_CLASS_VARIABLE_TYPE
        elif n.tag == UA_OBJECT_TYPE_TAG:
            node_class = NODE_CLASS_OBJECT_TYPE
        elif n.tag == UA_REFERENCE_TYPE_TAG:
            node_class = NODE_CLASS_REFERENCE_TYPE
        elif n.tag == UA_DATA_TYPE_TAG:
            node_class = NODE_CLASS_DATA_TYPE
        elif n.tag == UA_METHOD_TAG:
            node_class = NODE_CLASS_METHOD

        if node_class:
            parse_element(source, n.tag)
            nodeid = NodeId.parse(n.attrib['NodeId'])
            browse_name = QName.parse(n.attrib['BrowseName'])
            description = localized_text_of_child(n, UA_DESCRIPTION_TAG)
            display_name = localized_text_of_child(n, UA_DISPLAY_NAME_TAG)
            references = collect_node_references(n, aliases)

            node = Node(
                1 + len(nodes),
                node_class,
                nodeid,
                browse_name,
                description,
                display_name,
                references
            )

            if parse_values and ((node_class == NODE_CLASS_VARIABLE) or (node_class == NODE_CLASS_VARIABLE_TYPE)):
                node.value = collect_variable_value(n)

                accesslevel = n.get('AccessLevel', None)

                if accesslevel is not None:
                    try:
                        node.accesslevel = int(accesslevel)
                    except ValueError:
                        raise ParseError('Non integer AccessLevel for node %s' % n['NodeId'])

            nodes.append(node)
        elif n.tag == UA_ALIASES_TAG:
            parse_element(source, n.tag)
            aliases.update(collect_aliases(n))
        else:
            skip_element(source, n.tag)

        n.clear()


def count_node_classes(nodes):
    counts = {}

    for c in NODE_CLASSES:
        counts[c] = 0

    for n in nodes:
        counts[n.nodeclass] = 1 + counts[n.nodeclass]

    return counts


def generate_string(data):
    assert data is None or isinstance(data, str)

    if data is not None:
        return '{%d, 1, (SOPC_Byte*) "%s"}' % (len(data), data.replace('"', '\\"'))

    return '{0, 0, NULL}'


def generate_guid(data):
    assert isinstance(data, uuid.UUID)

    members = list(data.fields[0:5])

    for i in range(5, -1, -1):
        members.append((data.fields[5] >> (8*i)) & 0xFF)

    return '{0x%02x, 0x%02x, 0x%02x, {0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x}}' % tuple(members)


def generate_byte_string(data):
    return generate_string(data)


def c_nodeid_var_name(idx):
    return 'nodeid_' + str(idx)


def c_expanded_nodeid_var_name(idx):
    return 'ex_nodeid_' + str(idx)


def generate_node_id_decls(idx, nodeid):
    var_name = c_nodeid_var_name(idx)
    ex_var_name = c_expanded_nodeid_var_name(idx)
    id_type = C_IDENTIFIER_TYPES[nodeid.ty]
    data_struct_field = '.Data.' + id_type[len('SOPC_IdentifierType_'):]
    data_struct_val = None

    if nodeid.ty == ID_TYPE_NUMERIC:
        data_struct_val = str(nodeid.data)
    elif nodeid.ty == ID_TYPE_STRING:
        data_struct_val = generate_string(nodeid.data)
    elif nodeid.ty == ID_TYPE_GUID:
        data_struct_val = generate_guid(nodeid.data)
    elif nodeid.ty == ID_TYPE_BYTESTRING:
        data_struct_val = generate_byte_string(nodeid.data)

    decls = 'static SOPC_NodeId %s = {%s, %d, %s = %s};\n' %\
            (var_name, id_type, nodeid.ns or 0, data_struct_field, data_struct_val)

    decls += 'static SOPC_ExpandedNodeId %s = {{%s, %d, %s = %s}, {0, 0, NULL}, 0};\n' %\
             (ex_var_name, id_type, nodeid.ns or 0, data_struct_field, data_struct_val)

    return decls


def generate_dummy_nodeid_usage(n_nodes, fd):
    fd.write('void* avoid_unused_nodes_var[] = {\n')

    for i in range(0, n_nodes):
        fd.write('&%s, &%s,\n' % (c_nodeid_var_name(i+1), c_expanded_nodeid_var_name(i+1)))

    fd.write('};\n')


def generate_qname(qname):
    assert isinstance(qname, QName)
    return '{%d, %s}' % (qname.ns or 0, generate_string(qname.name))


def generate_browse_names(nodes, fd):
    fd.write('static SOPC_QualifiedName BrowseName[NB + 1] = {\n{0, {0, 0, NULL}},\n')

    for n in nodes:
        fd.write(generate_qname(n.browse_name) + (', /* %s */\n' % n.nodeid))

    fd.write('};\n')


def generate_relation_begin_end(nodes, name, attr_name, is_end, fd):
    rel_type = 'end' if is_end else 'begin'
    first_element = -1 if is_end else 0
    fd.write('static int %s_%s[] = {%d, ' % (name, rel_type, first_element))

    is_first = True
    n_rel_total = 0

    for n in nodes:
        if not is_first:
            prefix = ', '
        else:
            prefix = ''

        val = getattr(n, attr_name)

        if val is None:
            n_rel = 0
        elif isinstance(val, list):
            n_rel = len(val)
        else:
            n_rel = 1

        fd.write('%s%d' % (prefix, n_rel_total + (n_rel if is_end else 1)))

        n_rel_total += n_rel
        is_first = False

    fd.write('};\n')


def generate_localized_text_relations(nodes, name, attr_name, fd):
    fd.write('static SOPC_LocalizedText %s[] = {\n{{0, 0, NULL}, {0, 0, NULL}},\n' % name)

    for n in nodes:
        val = getattr(n, attr_name)

        if val is not None:
            fd.write('{%s, %s},\n' % (generate_string(val.locale), generate_string(val.text)))
        else:
            fd.write('{%s, %s},\n' % (generate_string(None), generate_string(None)))

    fd.write('};\n')

    generate_relation_begin_end(nodes, name, attr_name, False, fd)
    generate_relation_begin_end(nodes, name, attr_name, True, fd)


def generate_references(nodes, fd):
    generate_relation_begin_end(nodes, 'reference', 'references', False, fd)
    generate_relation_begin_end(nodes, 'reference', 'references', True, fd)
    node_dict = {str(n.nodeid): n for n in nodes}

    # Reference type
    fd.write('static SOPC_NodeId* reference_type[] = {NULL')

    for n in nodes:
        if n.idonly:
            continue

        for ref in n.references:
            fd.write(', &' + c_nodeid_var_name(node_dict[ref.ty].idx))

    fd.write('};\n')

    # Reference target
    fd.write('static SOPC_ExpandedNodeId* reference_target[] = {\nNULL,\n')

    for n in nodes:
        if n.idonly:
            continue

        for ref in n.references:
            fd.write('&' + c_expanded_nodeid_var_name(node_dict[ref.target].idx) + ',\n')

    fd.write('};\n')

    # Reference direction
    fd.write('static bool reference_isForward[] = {false')

    for n in nodes:
        if n.idonly:
            continue

        for ref in n.references:
            fd.write(', ' + ('true' if ref.is_forward else 'false'))

    fd.write('};\n')


def generate_nodeid_array(nodes, fd):
    fd.write('static SOPC_NodeId* NodeId[NB+1] = {NULL,\n')

    for n in nodes:
        fd.write('&' + c_nodeid_var_name(n.idx) + ',\n')
    fd.write('};\n')


def generate_node_classes(nodes, fd):
    fd.write('static OpcUa_NodeClass NodeClass[NB+1] = {\nOpcUa_NodeClass_Unspecified,\n')

    c_node_classes = [
        'OpcUa_NodeClass_View',
        'OpcUa_NodeClass_Object',
        'OpcUa_NodeClass_Variable',
        'OpcUa_NodeClass_VariableType',
        'OpcUa_NodeClass_ObjectType',
        'OpcUa_NodeClass_ReferenceType',
        'OpcUa_NodeClass_DataType',
        'OpcUa_NodeClass_Method',
    ]

    for n in nodes:
        fd.write(c_node_classes[n.nodeclass] + ',\n')

    fd.write('};\n')


def generate_variable_values(nodes, fd):
    fd.write('SOPC_Variant Value[NB_VARIABLES + NB_VARIABLE_TYPES + 1] = {\nDEFAULT_VARIANT,\n')

    for n in [n for n in nodes if n.nodeclass == NODE_CLASS_VARIABLE or n.nodeclass == NODE_CLASS_VARIABLE_TYPE]:
        if n.value is None:
            fd.write('DEFAULT_VARIANT,\n')
            continue

        if n.value.ty == VALUE_TYPE_BOOL:
            fd.write('{true, SOPC_Boolean_Id, SOPC_VariantArrayType_SingleValue, {.Boolean=%s}},\n' %
                     ('true' if n.value.val else 'false'))
        elif n.value.ty == VALUE_TYPE_STRING:
            fd.write('{true, SOPC_String_Id, SOPC_VariantArrayType_SingleValue, {.String=%s}},\n' %
                     generate_string(n.value.val))
        elif n.value.ty == VALUE_TYPE_BYTESTRING:
            fd.write('{true, SOPC_ByteString_Id, SOPC_VariantArrayType_SingleValue, {.Bstring=%s}},\n' %
                     generate_string(n.value.val))
        elif n.value.ty == VALUE_TYPE_BYTE:
            fd.write('{true, SOPC_Byte_Id, SOPC_VariantArrayType_SingleValue, {.Byte=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_INT16:
            fd.write('{true, SOPC_Int16_Id, SOPC_VariantArrayType_SingleValue, {.Int16=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_INT32:
            fd.write('{true, SOPC_Int32_Id, SOPC_VariantArrayType_SingleValue, {.Int32=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_INT64:
            fd.write('{true, SOPC_Int64_Id, SOPC_VariantArrayType_SingleValue, {.Int64=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_SBYTE:
            fd.write('{true, SOPC_SByte_Id, SOPC_VariantArrayType_SingleValue, {.Sbyte=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_UINT16:
            fd.write('{true, SOPC_UInt16_Id, SOPC_VariantArrayType_SingleValue, {.Uint16=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_UINT32:
            fd.write('{true, SOPC_UInt32_Id, SOPC_VariantArrayType_SingleValue, {.Uint32=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_UINT64:
            fd.write('{true, SOPC_UInt64_Id, SOPC_VariantArrayType_SingleValue, {.Uint64=%d}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_FLOAT:
            fd.write('{true, SOPC_Float_Id, SOPC_VariantArrayType_SingleValue, {.Floatv=%f}},\n' % n.value.val)
        elif n.value.ty == VALUE_TYPE_DOUBLE:
            fd.write('{true, SOPC_Double_Id, SOPC_VariantArrayType_SingleValue, {.Doublev=%f}},\n' % n.value.val)
        else:
            raise CodeGenerationError('Unsupported value type %d for node %s' % (n.value.ty, n.nodeid))

    fd.write('};\n')


def generate_status_codes(nodes, fd):
    fd.write('static SOPC_StatusCode status_code[] = {\nOpcUa_BadDataUnavailable,\n')

    for n in [n for n in nodes if n.nodeclass == NODE_CLASS_VARIABLE or n.nodeclass == NODE_CLASS_VARIABLE_TYPE]:
        fd.write('0x00000000,\n' if n.value is not None else 'OpcUa_BadDataUnavailable,\n')

    fd.write('};\n')


def generate_access_levels(nodes, fd):
    fd.write('static SOPC_Byte AccessLevel[] = {\n0,\n')

    for n in [n for n in nodes if n.nodeclass == NODE_CLASS_VARIABLE or n.nodeclass == NODE_CLASS_VARIABLE_TYPE]:
        fd.write(('%d,\n' % n.accesslevel) if n.accesslevel is not None else '1,\n')

    fd.write('};\n')


def exclude_idonly_nodes(nodes):
    return [n for n in nodes if not n.idonly]


def generate_c_code(nodes, fd):
    fd.write(c_header)
    full_nodes = list(exclude_idonly_nodes(nodes))

    class_count = count_node_classes(full_nodes)

    fd.write('#define NB_VIEWS           %d\n' % class_count[NODE_CLASS_VIEW])
    fd.write('#define NB_OBJECTS         %d\n' % class_count[NODE_CLASS_OBJECT])
    fd.write('#define NB_VARIABLES       %d\n' % class_count[NODE_CLASS_VARIABLE])
    fd.write('#define NB_VARIABLE_TYPES  %d\n' % class_count[NODE_CLASS_VARIABLE_TYPE])
    fd.write('#define NB_OBJECT_TYPES    %d\n' % class_count[NODE_CLASS_OBJECT_TYPE])
    fd.write('#define NB_REFERENCE_TYPES %d\n' % class_count[NODE_CLASS_REFERENCE_TYPE])
    fd.write('#define NB_DATA_TYPES      %d\n' % class_count[NODE_CLASS_DATA_TYPE])
    fd.write('#define NB_METHODS         %d\n' % class_count[NODE_CLASS_METHOD])

    n_nodes = sum([v for (_, v) in class_count.items()])

    fd.write('#define NB                 %d\n' % n_nodes)

    fd.write('''
#define toSOPC_String(s) ((SOPC_Byte*)s)
#define DEFAULT_VARIANT  {true, SOPC_Null_Id, SOPC_VariantArrayType_SingleValue,{0}}

''')

    # NodeId declarations
    for n in nodes:
        fd.write(generate_node_id_decls(n.idx, n.nodeid))

    fd.write('\n')
    generate_dummy_nodeid_usage(len(nodes), fd)
    fd.write('\n')
    generate_browse_names(full_nodes, fd)
    fd.write('\n')
    generate_localized_text_relations(full_nodes, 'Description', 'description', fd)
    fd.write('\n')
    generate_localized_text_relations(full_nodes, 'DisplayName', 'display_name', fd)
    fd.write('\n')
    generate_references(nodes, fd)
    fd.write('\n')
    generate_nodeid_array(full_nodes, fd)
    fd.write('\n')
    generate_node_classes(full_nodes, fd)
    fd.write('\n')
    generate_variable_values(full_nodes, fd)
    fd.write('\n')
    generate_status_codes(full_nodes, fd)
    fd.write('\n')
    generate_access_levels(full_nodes, fd)
    fd.write('\n')

    fd.write(c_footer)


def resolve_references(nodes):
    external_nodes = {}
    node_dict = {str(n.nodeid) for n in nodes}

    def add_external(nodeid):
        external = Node.make_idonly(NodeId.parse(nodeid))
        external_nodes[str(external.nodeid)] = external

    for n in nodes:
        for ref in n.references:
            if ref.ty not in node_dict and ref.ty not in external_nodes:
                add_external(ref.ty)

            if ref.target not in node_dict and ref.target not in external_nodes:
                add_external(ref.target)

    return list(external_nodes.values())


def main():
    argparser = argparse.ArgumentParser(description='Generate the INGOPCS address space from an OPC UA NodeSet')
    argparser.add_argument('xml_file', metavar='XML_FILE',
                           help='Path to the address space XML file')
    argparser.add_argument('c_file', metavar='C_FILE',
                           help='Path to the generated C file')
    args = argparser.parse_args()

    print('Parsing XML model...')
    with open(args.xml_file, 'rb') as fd:
        try:
            nodes = parse_address_space(iterparse(fd, events=('start', 'end')))
        except ParseError as e:
            sys.stderr.write('Woops, an error occurred: %s\n' % str(e))
            sys.exit(1)

    print('Resolving references...')
    try:
        external_nodes = resolve_references(nodes)

        print('Added %d external NodeIds' % len(external_nodes))

        for n in external_nodes:
            n.nodeclass = NODE_CLASS_EXTERNAL
            n.idx = 1 + len(nodes)
            nodes.append(n)
    except ResolveError as e:
        sys.stderr.write('Woops, an error occurred: %s\n' % str(e))
        sys.exit(1)

    # Sort nodes to regroup them by categories
    nodes.sort(key=lambda x: (x.nodeclass, x.idx))

    print('Done. Generating C code...')
    with open(args.c_file, 'w') as fd:
        try:
            generate_c_code(nodes, fd)
        except CodeGenerationError as e:
            sys.stderr.write('Woops, an error occurred: %s\n' % str(e))
            sys.exit(1)

    print('Done.')


if __name__ == '__main__':
    main()
