/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    subscription_mgr_i
REFINES
    subscription_mgr
    
SEES
    constants,
    message_in_bs,
    message_out_bs,
    write_value_pointer_bs,
    address_space,
    request_handle_bs
    
DEFINITIONS
    "definitions.def"

IMPORTS
    subscription_core,
    msg_subscription_create_bs,
    msg_subscription_create_monitored_item,
    subscription_create_monitored_item_it,
    monitored_item_queue_it_bs
    
PROMOTES
    is_valid_subscription

LOCAL_OPERATIONS

    fill_publish_response_msg (p_resp_msg, p_subscription, p_moreNotifs) =
    PRE
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_subscription : t_subscription_i & p_subscription : t_subscription &
        p_moreNotifs : BOOL
    THEN
        skip
    END
    ;
    
    fill_response_subscription_create_monitored_items (p_subscription, p_tsToReturn, p_req_msg, p_resp_msg, p_nb_monitored_items) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription &
        p_tsToReturn : t_TimestampsToReturn_i &
        p_tsToReturn : t_TimestampsToReturn &
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = c_msg_in &
        a_msg_in_type = e_msg_subscription_publish_req &
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_resp_msg = c_msg_out &
        a_msg_out_type = e_msg_subscription_publish_resp &
        p_nb_monitored_items : NAT &
        p_nb_monitored_items : t_monitoredItemReqIndex &
        p_nb_monitored_items = nb_monitored_items
    THEN
        LET l_monitoredItemResp_StatusCode BE
            /* Evaluate the expected valid responses for which a monitored item should be allocated (e_sc_ok case) */
            l_monitoredItemResp_StatusCode = 
            %mi_index.(mi_index : t_monitoredItemReqIndex &
                mi_index : 1..nb_monitored_items &
                /* ith node id has a node in the Address Space */
                mi_index : dom(MonitoredItemReq_NodeId) &
                /* Node is in the domain of the attribute */
                mi_index : dom(MonitoredItemReq_AttributeId)
                /* TODO: add use-access levels */
                |
                {TRUE |-> e_sc_bad_attribute_id_invalid,
                 FALSE |-> {TRUE |-> e_sc_bad_monitoring_mode_invalid,
                            FALSE |-> {TRUE |-> e_sc_bad_monitored_item_filter_unsupported,
                                       FALSE |-> {TRUE |-> e_sc_bad_node_id_unknown,
                                                  FALSE |-> {TRUE |-> e_sc_bad_attribute_id_invalid,
                                                             FALSE |-> {TRUE |-> e_sc_bad_too_many_monitored_items,
                                                                        FALSE |-> e_sc_ok
                                                                       }(bool(t_monitoredItemPointer = s_monitoredItemPointer or
                                                                              t_monitoredItemId = s_monitoredItemId))
                                                            }(bool(a_NodeId~(MonitoredItemReq_NodeId(mi_index)) /:
                                                                   dom(AttributeID_Node_Variant(MonitoredItemReq_AttributeId(mi_index)))))
                                                 }(bool(MonitoredItemReq_NodeId(mi_index) /: dom(a_NodeId~)))
                                      }(bool(MonitoredItemReq_FilterPresence(mi_index) = TRUE))
                           }(bool(MonitoredItemReq_ValidMonitoringMode(mi_index) = FALSE))
                }(bool(mi_index /: dom(MonitoredItemReq_AttributeId)))               
            )
        IN
            ANY max_mi_ids, max_mi_pointers, s_maximums, nb_allocated_monitored_items WHERE
                /* Define the number of really allocated monitored items (minimum between expected and available) */
                max_mi_ids = card(t_monitoredItemId - s_monitoredItemId) &
                max_mi_pointers = card(t_monitoredItemPointer - s_monitoredItemPointer) &
                s_maximums = {max_mi_ids} \/ {max_mi_pointers} \/ {card((l_monitoredItemResp_StatusCode |> {e_sc_ok}))} &
                nb_allocated_monitored_items = min(s_maximums)
            THEN
                LET l_allocMonitoredItemResp_StatusCode BE
                    /* Define the valid responses restricted by number of allocated monitored items */
                    l_allocMonitoredItemResp_StatusCode =
                      %mi_index.(mi_index : t_monitoredItemReqIndex &
                                 mi_index : 1..nb_monitored_items
                                 |
                                 {TRUE |-> l_monitoredItemResp_StatusCode(mi_index), /* Copy if no restriction due to allocation */
                                  FALSE |-> {TRUE |-> e_sc_bad_too_many_monitored_items, /* Restriction due to allocation */
                                             FALSE |-> l_monitoredItemResp_StatusCode(mi_index) /* Copy result if not e_sc_ok */
                                            }(bool(l_monitoredItemResp_StatusCode(mi_index) = e_sc_ok))
                                 }(bool(card((1..mi_index <| l_monitoredItemResp_StatusCode |> {e_sc_ok})) < 
                                               nb_allocated_monitored_items))
                                )
                IN
                    /* Define monitored items allocated (with unique id) */
                    ANY s_newMonitoredItemId, miIndexToMiId, s_newMonitoredItemPointer, l_MonitoredItemResp_Id WHERE
                      
                        /* Allocate the new monitored items */
                        s_newMonitoredItemId <: t_monitoredItemId &
                        s_newMonitoredItemId /\ s_monitoredItemId = {} &
                        
                        miIndexToMiId : dom(l_allocMonitoredItemResp_StatusCode |> {e_sc_ok}) >-> t_monitoredItemId &
                        ran(miIndexToMiId) = s_newMonitoredItemId &
                        
                        s_newMonitoredItemPointer <: t_monitoredItemPointer &
                        s_newMonitoredItemPointer /\ s_monitoredItemPointer = {} &
                        card(s_newMonitoredItemPointer) = card(s_newMonitoredItemId) &
                        
                        /* Reserve those new monitored items for the response */
                        l_MonitoredItemResp_Id : t_monitoredItemReqIndex +-> t_monitoredItemId_i &
                        l_MonitoredItemResp_Id[dom(l_allocMonitoredItemResp_StatusCode |>> {e_sc_ok})] = {c_monitoredItemId_indet} &
                        l_MonitoredItemResp_Id[dom(l_allocMonitoredItemResp_StatusCode |> {e_sc_ok})] = ran(miIndexToMiId)
                    THEN
                        /* Define the queues of monitored items that will be modified */
                        LET miSubQueue, miIndexToNodeIds, s_miNodeQueues, s_miQueues BE
                            miSubQueue = a_monitoredItemQueue(p_subscription) &
                            /* Nodes ids concerned by the new monitored items */
                            miIndexToNodeIds = %mi_index.(mi_index : t_monitoredItemReqIndex &
                                                          mi_index : 1..nb_monitored_items &
                                                          l_allocMonitoredItemResp_StatusCode (mi_index) = e_sc_ok
                                                          |
                                                          MonitoredItemReq_NodeId(mi_index)) &
                            s_miNodeQueues = a_nodeToMonitoredItemQueue[ran(miIndexToNodeIds)] &
                            s_miQueues = {miSubQueue} \/ s_miNodeQueues
                        IN
                            /* Set response variables */
                            MonitoredItemResp_StatusCode := l_allocMonitoredItemResp_StatusCode ||
                            MonitoredItemResp_Id := l_MonitoredItemResp_Id ||
                            
                            /* Update set of valid monitored items and their properties */
                            s_monitoredItemId := s_monitoredItemId \/ s_newMonitoredItemId ||
                            s_monitoredItemPointer := s_monitoredItemPointer \/ s_newMonitoredItemPointer ||
                            a_monitoredItemId, a_monitoredItemSubs, 
                            a_monitored_item_notifications, a_defined_monitored_items
                            :(/* Associate new pointers with new ids */
                              a_monitoredItemId <: a_monitoredItemId$0 &
                              s_newMonitoredItemPointer <<| a_monitoredItemId =
                               s_newMonitoredItemPointer <<| a_monitoredItemId$0 &
                              a_monitoredItemId[s_newMonitoredItemPointer] = s_newMonitoredItemId &
                               
                              /* Associate new pointers with current subscription */
                              a_monitoredItemSubs <: a_monitoredItemSubs$0 &
                              s_newMonitoredItemPointer <<| a_monitoredItemSubs =
                               s_newMonitoredItemPointer <<| a_monitoredItemSubs$0 &
                              a_monitoredItemSubs[s_newMonitoredItemPointer] = {p_subscription} &
                              /* Add notifications to subscription notification queue */
                              a_monitored_item_notifications <: a_monitored_item_notifications$0 &
                              {a_pendingNotificationQueue(p_subscription)} <<| a_monitored_item_notifications =
                               {a_pendingNotificationQueue(p_subscription)} <<| a_monitored_item_notifications$0 &
                               a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}] =
                               s_monitoredItemPointer &
                              /* Add monitored items to the monitored items queues */
                              a_defined_monitored_items <: a_defined_monitored_items$0 &
                              s_miQueues <<| a_defined_monitored_items =
                               s_miQueues <<| a_defined_monitored_items$0 &
                              a_defined_monitored_items[s_miQueues] = s_monitoredItemPointer                          
                            )
                       END
                    END
                END
            END
        END
    END
    ;
    

    create_notification_on_monitored_items_if_data_changed (p_monitoredItemQueue, p_old_wv_pointer, p_new_wv_pointer) =
    PRE
        p_monitoredItemQueue : t_monitoredItemQueue_i &
        p_monitoredItemQueue : t_monitoredItemQueue &
        p_old_wv_pointer : t_WriteValuePointer_i &
        p_old_wv_pointer : t_WriteValuePointer &
        p_new_wv_pointer : t_WriteValuePointer_i &
        p_new_wv_pointer : t_WriteValuePointer
    THEN
        /* notifications may have been triggered */
        a_monitored_item_notifications
        :(a_monitored_item_notifications$0 <: a_monitored_item_notifications)
        /* Note: if NodeId / AttributeId are represented in t_WriteValuePointer, 
           it is possible to describe first part of criteria to generate notification.
           But other filters will be necessary (index array, ...) */
    END

OPERATIONS
    
    /* LOCAL OPERATIONS */
    fill_publish_response_msg (p_resp_msg, p_subscription, p_moreNotifs) =
    BEGIN
        set_msg_publish_resp_subscription (p_resp_msg, p_subscription);
        /* TODO: fill the availableSeqNum of message: */
        /* - allocate availableSequenceNumbers
        - iter on seq nums based on nb_avail_seq_nums */
        set_msg_publish_resp_notificationMsg (p_resp_msg, p_moreNotifs)
    END
    ;
    
    fill_response_subscription_create_monitored_items (p_subscription, p_tsToReturn, p_req_msg, p_resp_msg, p_nb_monitored_items) =
    VAR
        l_continue,
        l_index,
        l_bres,
        l_nid,
        l_aid,
        l_monitMode,
        l_clientHandle,
        l_samplingItv,
        l_queueSize,
        l_node,
        l_sc,
        l_ncl,
        l_value,
        l_valueSc,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_revSamplingItv, 
        l_revQueueSize
    IN
        l_continue <-- init_iter_monitored_item_request(p_nb_monitored_items);
        WHILE l_continue = TRUE DO
            l_node := c_Node_indet;
            l_value := c_Variant_indet;
            l_valueSc := e_sc_ok;
            l_monitoredItemId := c_monitoredItemId_indet;
            l_revSamplingItv := c_opcua_duration_indet;
            l_revQueueSize := 0;
            l_continue, l_index <-- continue_iter_monitored_item_request;
            l_bres, l_sc, l_nid, l_aid, l_monitMode, l_clientHandle, l_samplingItv, l_queueSize
              <-- getall_monitored_item_req_params(p_req_msg, l_index);
            IF l_bres = TRUE
            THEN
                l_bres, l_node <-- readall_AddressSpace_Node (l_nid);
                IF l_bres = FALSE
                THEN
                    l_sc := e_sc_bad_node_id_unknown
                END
            END
            ;
            IF l_sc = e_sc_ok
            THEN
                l_sc, l_ncl, l_value <-- read_NodeClass_Attribute(l_node, l_aid);
                IF l_ncl = e_ncl_Variable
                THEN
                    l_valueSc <-- get_Value_StatusCode (l_node)
                END
            END
            ;
            IF l_sc = e_sc_ok
            THEN
                l_sc, l_monitoredItemPointer, l_monitoredItemId <-- create_monitored_item (p_subscription,
                                                                                           l_nid,
                                                                                           l_aid,
                                                                                           l_value,
                                                                                           l_valueSc,
                                                                                           p_tsToReturn,
                                                                                           l_monitMode,
                                                                                           l_clientHandle);
                l_revSamplingItv, l_revQueueSize <-- compute_create_montitored_item_revised_params(l_queueSize)
            END
            ;
            setall_msg_monitored_item_resp_params (p_resp_msg, l_index, l_sc, l_monitoredItemId, l_revSamplingItv, l_revQueueSize)
              
        INVARIANT
            rreqs_to_iterate <: t_monitoredItemReqIndex &
            rreqs_iterated   <: t_monitoredItemReqIndex &
            rreqs_to_iterate /\ rreqs_iterated = {} &
            rreqs_to_iterate \/ rreqs_iterated = 1..nb_monitored_items &
            l_continue = bool(rreqs_to_iterate /= {})
            
            /* TODO: reprendre les propriétés de fill_response_subscription_create_monitored_items */
        VARIANT
            card(rreqs_to_iterate)
        END
    END
    ;
    
    create_notification_on_monitored_items_if_data_changed (p_monitoredItemQueue, p_old_wv_pointer, p_new_wv_pointer) =
    VAR
        l_continue,
        l_iterator,
        l_monitoredItemPointer,
        l_notification_triggered,
        
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_continue, l_iterator <-- init_iter_monitored_item (p_monitoredItemQueue);
        WHILE l_continue = TRUE DO
            l_continue, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, p_monitoredItemQueue);
            l_notification_triggered <-- is_notification_triggered (l_monitoredItemPointer, p_old_wv_pointer, p_new_wv_pointer);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <--getall_monitoredItemPointer (l_monitoredItemPointer);
            IF l_notification_triggered = TRUE
            THEN
                server_subscription_add_notification (l_subscription, l_monitoredItemPointer, p_new_wv_pointer)
            END
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &
            
            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue = bool(s_mi_to_iterate_it /= {})

        VARIANT
            card(s_mi_to_iterate_it)
        END
    END
    ;
    
    /* END OF LOCAL OPERATIONS */
    
    StatusCode_service <-- treat_create_subscription_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_sub,
        l_reqPublishInterval,
        l_reqLifetimeCount,
        l_reqMaxKeepAlive,
        l_maxNotificationsPerPublish,
        l_publishEnabled,
        l_subscription,
        l_revisedPublishInterval,
        l_revisedLifetimeCount,
        l_revisedMaxKeepAlive,
        l_revisedMaxNotificationsPerPublish
    IN
        l_session_has_subscription, l_sub <-- getall_subscription (p_session);
        IF l_session_has_subscription = FALSE
        THEN
            /* Extract create subscription parameters */
            l_reqPublishInterval, l_reqLifetimeCount, l_reqMaxKeepAlive, l_maxNotificationsPerPublish, l_publishEnabled
              <-- get_msg_create_subscription_req_params (p_req_msg);
            /* TODO: refuse publishEnabled = FALSE ? */
            
            IF l_publishEnabled = TRUE
            THEN
                /* Compute revised parameters */
                l_revisedPublishInterval, l_revisedLifetimeCount, l_revisedMaxKeepAlive, l_revisedMaxNotificationsPerPublish
                <-- compute_create_subscription_revised_params (p_session,
                    l_reqPublishInterval,
                    l_reqLifetimeCount,
                    l_reqMaxKeepAlive,
                    l_maxNotificationsPerPublish);
                
                /* Create subscription */
                StatusCode_service, l_subscription <-- create_subscription (p_session,
                    l_revisedPublishInterval,
                    l_revisedLifetimeCount,
                    l_revisedMaxKeepAlive,
                    l_revisedMaxNotificationsPerPublish,
                    l_publishEnabled);
                IF StatusCode_service = e_sc_ok 
                THEN
                    /* Fill values to response message */
                    set_msg_create_subscription_resp_params (p_resp_msg,
                        l_subscription, 
                        l_revisedPublishInterval,
                        l_revisedLifetimeCount,
                        l_revisedMaxKeepAlive)
                END
            ELSE
                StatusCode_service := e_sc_bad_invalid_argument
            END
        ELSE
            StatusCode_service := e_sc_bad_too_many_subscriptions
        END
    END
    ;
    
    StatusCode_service, async_resp_msg 
      <-- treat_subscription_publish_request (p_session, p_req_header, p_req_msg, p_req_handle, p_req_ctx, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_sub,
        l_req_exp_time,
        /*l_nb_subsciptionAcks,
        l_nb_avail_seq_nums,*/
        l_subscription,
        l_moreNotifs
    IN
        async_resp_msg := FALSE;
        l_session_has_subscription, l_sub <-- getall_subscription (p_session);
        IF l_session_has_subscription = TRUE
        THEN
            /* Extract values from header: expiration time for Publish Request */
            l_req_exp_time <-- get_msg_header_expiration_time (p_req_header);
            
            
            /* TODO: remove when used */
            nothing_msg_in (p_req_msg);
            /* TODO: Extract values from message: l_nb_subsciptionAcks <-- get_msg_publish_request_params (p_req_msg); */            
            /* TODO: allocate acks results array of response message */
            /* TODO: iter on sub_acks in LOCAL OP and ack it using acknowledge_publish_response (sub_id, seq_num) + fill results[] in resp :           
            <=> fill_read_response */
            
            StatusCode_service, async_resp_msg, l_subscription, l_moreNotifs
              <-- receive_publish_request (p_session, l_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg);

            IF StatusCode_service = e_sc_ok &
                async_resp_msg = FALSE
            THEN
                fill_publish_response_msg (p_resp_msg, l_subscription, l_moreNotifs)
            END
        ELSE
            StatusCode_service := e_sc_bad_no_subscription
        END
    END
    ;
    
    StatusCode_service <-- treat_subscription_create_monitored_items_req (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_sc,
        l_subscription,
        l_valid_subscription,
        l_timestampToRet,
        l_nb_monitored_items,
        l_bres
    IN
        l_sc, l_subscription, l_timestampToRet, l_nb_monitored_items <-- getall_msg_create_monitored_items_req_params (p_req_msg);
        IF l_sc = e_sc_ok
        THEN
            l_valid_subscription <-- is_valid_subscription_on_session (p_session, l_subscription);
            IF l_valid_subscription = TRUE
            THEN
                l_bres <-- alloc_msg_create_monitored_items_resp_results (p_resp_msg, l_nb_monitored_items);    
                IF l_bres = TRUE
                THEN
                    fill_response_subscription_create_monitored_items 
                      (l_subscription, l_timestampToRet, p_req_msg, p_resp_msg, l_nb_monitored_items);
                    StatusCode_service := e_sc_ok
                ELSE
                    StatusCode_service := e_sc_bad_out_of_memory
                END                
            ELSE
                StatusCode_service := e_sc_bad_subscription_id_invalid
            END
        ELSE
            StatusCode_service := l_sc
        END
    END
    ;
    
    server_subscription_data_changed (p_old_write_value_pointer, p_new_write_value_pointer) =
    VAR
        l_nid,
        l_aid,
        l_nid_valid,
        l_node,
        l_monitoredItemQueue
    IN
        l_nid, l_aid <-- get_write_value_pointer_NodeId_AttributeId (p_new_write_value_pointer);
        l_nid_valid, l_node <-- readall_AddressSpace_Node (l_nid);
        IF l_nid_valid = TRUE
        THEN
            l_monitoredItemQueue <-- get_nodeToMonitoredItemQueue (l_nid);
            create_notification_on_monitored_items_if_data_changed 
             (l_monitoredItemQueue, p_old_write_value_pointer, p_new_write_value_pointer)
        END
    END
    ;
    
    server_subscription_publish_timeout (p_subscription) =
    VAR
        l_closeSubscription,
        l_msg_to_send,
        l_msg_sc,
        l_session,
        l_publish_resp_msg,
        l_req_handle,
        l_req_context,
        l_moreNotifs,
        l_validPublishingReqQueued
    IN
        l_closeSubscription, l_msg_to_send, l_session, l_publish_resp_msg,
        l_req_handle, l_req_context, l_validPublishingReqQueued
          <-- server_subscription_core_publish_timeout_check_lifetime (p_subscription);
          
        IF l_closeSubscription = FALSE
        THEN
            l_msg_to_send, l_msg_sc, l_session, l_publish_resp_msg,
            l_req_handle, l_req_context, l_moreNotifs
              <-- server_subscription_core_publish_timeout (p_subscription, l_validPublishingReqQueued);
            
            IF l_msg_to_send = TRUE
            THEN
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_moreNotifs);
                generate_internal_send_publish_response_event (l_session, 
                                                               l_publish_resp_msg, 
                                                               l_req_handle,
                                                               l_req_context,
                                                               l_msg_sc);
                IF l_moreNotifs = TRUE
                THEN
                    /* TODO: move in a LOCAL operation and specify variables changes */
                    l_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_subscription);
                    WHILE l_moreNotifs = TRUE & l_validPublishingReqQueued = TRUE DO
                        l_msg_to_send, l_msg_sc, l_session, l_publish_resp_msg, 
                        l_req_handle, l_req_context, l_moreNotifs <-- server_subscription_core_publish_timeout_return_moreNotifs (p_subscription);                        
                        fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_moreNotifs);
                        generate_internal_send_publish_response_event (l_session, 
                            l_publish_resp_msg, 
                            l_req_handle,
                            l_req_context,
                            l_msg_sc);
                        IF l_moreNotifs = TRUE
                        THEN
                            l_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_subscription)
                        END
                    INVARIANT
                        l_validPublishingReqQueued = validPublishReqQueued &
                        l_moreNotifs = bool(a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}] /= {})
                    VARIANT
                        card(a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}]) +
                        /* necessary in case allocation failed: notification queue will not decrease */
                        card(a_publish_responses~[{a_publishRequestQueue (p_subscription)}]) 
                    END                
                END
            END
        ELSE
            close_subscription (p_subscription);
            IF l_msg_to_send = TRUE /* Seems to be impossible: see server_subscription_core_publish_timeout_check_lifetime */
            THEN
                /* Fill IssueStatusChangedNotification message */
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, FALSE);
                generate_internal_send_publish_response_event (l_session, 
                                                               l_publish_resp_msg, 
                                                               l_req_handle, 
                                                               l_req_context,
                                                               e_sc_ok)
            END
        END
    END
    ;
    
    server_subscription_session_inactive (p_session, p_newSessionState) =
    VAR
        l_has_sub,
        l_sub
    IN
        l_has_sub, l_sub <-- getall_subscription (p_session);
        IF l_has_sub = TRUE
        THEN
            IF p_newSessionState = e_session_scOrphaned or 
               p_newSessionState = e_session_scActivating or 
               p_newSessionState = e_session_closed
            THEN
                /* SC is not valid anymore for the session
                   => publish requests are not valid anymore on another SC */
                empty_session_publish_requests (l_sub);
                IF p_newSessionState = e_session_closed
                THEN
                    /* session is not valid anymore */
                    remove_subscription_session (l_sub, p_session)
                END
            END
        END
    END
    
END
