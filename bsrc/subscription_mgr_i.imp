/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    subscription_mgr_i
REFINES
    subscription_mgr
    
SEES
    constants,
    message_in_bs,
    message_out_bs,
    write_value_pointer_bs,
    address_space_bs,
    request_handle_bs
    
IMPORTS
    subscription_core,
    msg_subscription_create_bs,
    msg_subscription_publish_bs,
    msg_subscription_create_monitored_item
    
PROMOTES
    is_valid_subscription

LOCAL_OPERATIONS

    fill_publish_response_msg (p_resp_msg, p_subscription, p_notifMsg) =
    PRE
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_subscription : t_subscription_i & p_subscription : t_subscription &
        p_notifMsg : t_notif_msg_i /* indet in case of keep alive response */
    THEN
        skip
    END

OPERATIONS
    
    /* LOCAL OPERATIONS */
    fill_publish_response_msg (p_resp_msg, p_subscription, p_notifMsg) =
    BEGIN
        set_msg_publish_resp_subscription (p_resp_msg, p_subscription);
        /* TODO: fill the availableSeqNum of message: */
        /* - allocate availableSequenceNumbers
        - iter on seq nums based on nb_avail_seq_nums */
        set_msg_publish_resp_notificationMsg (p_resp_msg, p_notifMsg)
    END
    ;
    
    /* END OF LOCAL OPERATIONS */
    
    StatusCode_service <-- treat_create_subscription_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_reqPublishInterval,
        l_reqLifetimeCount,
        l_reqMaxKeepAlive,
        l_maxNotificationsPerPublish,
        l_publishEnabled,
        l_subscription,
        l_revisedPublishInterval,
        l_revisedLifetimeCount,
        l_revisedMaxKeepAlive
    IN
        l_session_has_subscription <-- has_subscription (p_session);
        IF l_session_has_subscription = FALSE
        THEN
            /* Extract create subscription parameters */
            l_reqPublishInterval, l_reqLifetimeCount, l_reqMaxKeepAlive, l_maxNotificationsPerPublish, l_publishEnabled
              <-- get_msg_create_subscription_req_params (p_req_msg);
            /* TODO: refuse publishEnabled = FALSE ? */
            
            IF l_publishEnabled = TRUE
            THEN
                /* Compute revised parameters */
                l_revisedPublishInterval, l_revisedLifetimeCount, l_revisedMaxKeepAlive 
                <-- compute_create_subscription_revised_params (p_session,
                    l_reqPublishInterval,
                    l_reqLifetimeCount,
                    l_reqMaxKeepAlive);
                
                /* Create subscription */
                StatusCode_service, l_subscription <-- create_subscription (p_session,
                    l_revisedPublishInterval,
                    l_revisedLifetimeCount,
                    l_revisedMaxKeepAlive,
                    l_maxNotificationsPerPublish,
                    l_publishEnabled);
                IF StatusCode_service = e_sc_ok 
                THEN
                    /* Fill values to response message */
                    set_msg_create_subscription_resp_params (p_resp_msg,
                        l_subscription, 
                        l_revisedPublishInterval,
                        l_revisedLifetimeCount,
                        l_revisedMaxKeepAlive)
                END
            ELSE
                StatusCode_service := e_sc_bad_invalid_argument
            END
        ELSE
            StatusCode_service := e_sc_bad_too_many_subscriptions
        END
    END
    ;
    
    StatusCode_service, async_resp_msg 
      <-- treat_subscription_publish_request (p_session, p_req_header, p_req_msg, p_req_handle, p_req_ctx, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_req_exp_time,
        /*l_nb_subsciptionAcks,
        l_nb_avail_seq_nums,*/
        l_subscription,
        l_notifMsg
    IN
        async_resp_msg := FALSE;
        l_session_has_subscription <-- has_subscription (p_session);
        IF l_session_has_subscription = TRUE
        THEN
            /* Extract values from header: expiration time for Publish Request */
            l_req_exp_time <-- get_msg_header_expiration_time (p_req_header);
            
            /* TODO: Extract values from message: l_nb_subsciptionAcks <-- get_msg_publish_request_params (p_req_msg); */            
            /* TODO: allocate acks results array of response message */
            /* TODO: iter on sub_acks in LOCAL OP and ack it using acknowledge_publish_response (sub_id, seq_num) + fill results[] in resp :           
            <=> fill_read_response */
            
            StatusCode_service, async_resp_msg, l_subscription, l_notifMsg 
              <-- receive_publish_request (p_session, l_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg);

            IF StatusCode_service = e_sc_ok &
                async_resp_msg = FALSE
            THEN
                fill_publish_response_msg (p_resp_msg, l_subscription, l_notifMsg)
            END
        ELSE
            StatusCode_service := e_sc_bad_no_subscription
        END
    END
    ;
    
    StatusCode_service <-- treat_subscription_create_monitored_items_req (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_sc,
        l_subscription,
        l_valid_subscription,
        l_timestampToRet,
        l_nb_monitored_items,
        l_bres
    IN
        l_sc, l_subscription, l_timestampToRet, l_nb_monitored_items <-- getall_msg_create_monitored_items_req_params (p_req_msg);
        IF l_sc = e_sc_ok
        THEN
            l_valid_subscription <-- is_valid_subscription_on_session (p_session, l_subscription);
            IF l_valid_subscription = TRUE
            THEN
                /* TODO: allocate response results array (alloc_msg_create_monitored_items_resp_results): check not outOfMemory */
                l_bres <-- alloc_msg_create_monitored_items_resp_results (p_resp_msg, l_nb_monitored_items);    
                IF l_bres = TRUE
                THEN
                    /* TODO: iterate on req message monitored items, for each:
                    - get monitored item req from req message (getall_monitored_item_req_params): check monitoringMode / nodeId validity / ...                
                    - retrieve node (index) from nodeId (readall_AddressSpace_Node): check if nodeIdUnkown
                    - check attribute validity using from node + aid (read_AddressSpace_Attribute_value): check if attributeIdInvalid
                    - compute revised parameters (compute_create_montitored_item_revised_params)
                    - add monitored item to subscription and retrieve status + Id (create_monitored_item)
                    - add result to response (setall_msg_monitored_item_resp_params)
                    */
                    StatusCode_service := e_sc_ok
                ELSE
                    StatusCode_service := e_sc_bad_out_of_memory
                END                
            ELSE
                StatusCode_service := e_sc_bad_subscription_id_invalid
            END
        ELSE
            StatusCode_service := l_sc
        END
    END
    ;
    
    server_subscription_data_changed (p_old_write_value_pointer, p_new_write_value_pointer) =
    VAR
        l_nid,
        l_aid,
        l_nid_valid,
        l_node,
        l_monitoredItemQueue
    IN
        l_nid, l_aid <-- get_write_value_pointer_NodeId_AttributeId (p_new_write_value_pointer);
        l_nid_valid, l_node <-- readall_AddressSpace_Node (l_nid);
        IF l_nid_valid = TRUE
        THEN
            l_monitoredItemQueue <-- get_nodeToMonitoredItemQueue (l_node)
            /* TODO: iterate on each monitoredItem, for each:
            - check regarding MI properties / aid / old value / new value if notification necessary
            - add notification to subscription (server_subscription_add_notification)
            */
        END
    END
    ;
    
    server_subscription_publish_timeout (p_subscription) =
    VAR
        l_closeSubscription,
        l_msg_to_send,
        l_session,
        l_publish_resp_msg,
        l_req_handle,
        l_req_context,
        l_notifMsg,
        l_moreNotifs,
        l_morePubReqs
    IN
        l_closeSubscription, l_msg_to_send, l_session, l_publish_resp_msg, l_req_handle, l_req_context, l_notifMsg
          <-- server_subscription_core_publish_timeout_check_lifetime (p_subscription);
        IF l_closeSubscription = FALSE
        THEN
            l_msg_to_send, l_session, l_publish_resp_msg, l_req_handle, l_req_context, l_notifMsg, l_moreNotifs, l_morePubReqs
              <-- server_subscription_core_publish_timeout (p_subscription);
            IF l_msg_to_send = TRUE
            THEN
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_notifMsg);
                generate_internal_send_publish_response_event (l_session, l_publish_resp_msg, l_req_handle, l_req_context);
                IF l_moreNotifs = TRUE & l_morePubReqs = TRUE
                THEN
                    skip
                    /* TODO: iterator to call until moreNotifications = FALSE or pubReqQueued = FALSE
                       - server_subscription_core_publish_timeout_return_moreNotifs
                       - fill_publish_response_msg
                       - generate_internal_send_publish_response_event
                    */
                END
            END
        ELSE
            delete_subscription (p_subscription);
            IF l_msg_to_send = TRUE /* Seems to be impossible: see server_subscription_core_publish_timeout_check_lifetime */
            THEN
                /* Fill IssueStateChangedNotification message */
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_notifMsg);
                generate_internal_send_publish_response_event (l_session, l_publish_resp_msg, l_req_handle, l_req_context)
            END
        END
    END
    ;
    
    server_subscription_session_inactive (p_session, p_newSessionState) =
    VAR
        l_has_sub,
        l_sub
    IN
        l_has_sub <-- has_subscription (p_session);
        IF l_has_sub = TRUE
        THEN
            IF p_newSessionState = e_session_scOrphaned or 
               p_newSessionState = e_session_scActivating or 
               p_newSessionState = e_session_closed
            THEN
                /* SC is not valid anymore for the session
                   => publish requests are not valid anymore on another SC */
                l_sub <-- get_subscription (p_session);
                empty_session_publish_requests (l_sub);
                IF p_newSessionState = e_session_closed
                THEN
                    /* session is not valid anymore */
                    remove_subscription_session (l_sub, p_session)
                END
            END
        END
    END
    
END
