/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    session_mgr_i
REFINES
    session_mgr
    
SEES
    constants,
    message_in_bs,
    message_out_bs,
    channel_mgr,
    request_handle_bs
    
IMPORTS
    session_core,
    session_mgr_it,
    session_request_handle_bs
    
PROMOTES
    get_session_user_or_indet,
    client_secure_channel_lost_session_sm,
    server_secure_channel_lost_session_sm,
    server_close_session_sm
    
LOCAL_OPERATIONS

    local_sc_activate_sessions_on_SC_connection (channel_config_idx) =
    PRE
        channel_config_idx : t_channel_config_idx_i &
        channel_config_idx : t_channel_config_idx
    THEN
        skip
    END
    
OPERATIONS
    
    local_sc_activate_sessions_on_SC_connection (channel_config_idx) =
    VAR
        l_continue,
        l_session,
        l_dom,
        l_channel_config_idx
    IN
        l_continue <-- init_iter_session;
        WHILE l_continue = TRUE DO
            l_continue, l_session <-- continue_iter_session;
            l_dom, l_channel_config_idx <-- getall_orphaned(l_session);
            IF  l_dom = TRUE &
                l_channel_config_idx = channel_config_idx
            THEN
                client_gen_activate_orphaned_session_internal_event (l_session, channel_config_idx)
            END;
            l_dom, l_channel_config_idx <-- getall_to_create(l_session);
            IF  l_dom = TRUE &
                l_channel_config_idx = channel_config_idx
            THEN
                reset_session_to_create(l_session);
                client_gen_create_session_internal_event (l_session, channel_config_idx)
            END
        INVARIANT
            sessions_to_iterate <: t_session &
            sessions_iterated   <: t_session &
            sessions_to_iterate /\ sessions_iterated = {} &
            sessions_to_iterate \/ sessions_iterated = t_session
        VARIANT
            card(sessions_to_iterate)
        END
    END
    ;
    
    /* END OF LOCAL OPERATIONS */
    
    session <-- client_receive_session_resp (channel, req_handle, resp_typ, resp_header, resp_msg) =
    VAR
        l_session,
        l_session_token,
        l_session_state,
        l_session_channel,      
        l_resp_status,
        l_session_user,
        l_bret
    IN
        l_bret := FALSE;
        l_session <-- client_get_session_and_remove_request_handle (req_handle);
        l_session_state <-- get_session_state_or_closed (l_session); // Note: state != closed => session is valid
        l_resp_status <-- read_msg_resp_header_service_status (resp_header);
        IF l_resp_status = e_sc_ok
        THEN         
            CASE resp_typ OF
                EITHER e_msg_session_create_resp THEN
                    IF l_session_state = e_session_creating THEN
                        l_session_channel <-- get_session_channel (l_session);
                        IF l_session_channel = channel THEN
                            l_session_token <-- read_create_session_msg_session_token (resp_msg);
                            l_bret <-- client_create_session_resp_sm (channel, l_session, l_session_token, resp_msg);
                            /* TODO: react if error: must drop the nonce, but do we close the connexion? */
                            // If session is created, trigger event for activation of session with async data
                            l_session_state <-- get_session_state_or_closed (l_session);
                            IF l_session_state = e_session_created
                            THEN
                                l_bret, l_session_user <-- getall_to_activate (l_session);
                                IF l_bret = TRUE &
                                    l_session_user /= c_user_indet
                                THEN
                                    reset_session_to_activate (l_session);
                                    client_gen_activate_user_session_internal_event (l_session, l_session_user)
                                END
                            ELSE
                                /* The session may be not e_session_created when Nonce generation failed */
                                l_bret := FALSE
                            END
                        ELSE
                            /* Bad secure channel */
                            skip
                        END
                    ELSE
                        /* Session invalid state */
                        skip
                    END
                OR e_msg_session_activate_resp THEN
                    IF l_session_state = e_session_userActivating or
                        l_session_state = e_session_scActivating
                    THEN
                        l_session_channel <-- get_session_channel (l_session);
                        IF l_session_channel = channel THEN	
                            l_bret <-- client_activate_session_resp_sm (channel, l_session, resp_msg)
                        ELSE
                            /* Bad secure channel */
                            skip
                        END
                    ELSE
                        /* Session invalid state */
                        skip
                    END
                OR e_msg_session_close_resp THEN
                    IF l_session_state = e_session_closing
                    THEN
                        l_session_channel <-- get_session_channel (l_session);
                        IF l_session_channel = channel THEN
                            client_remove_all_request_handles (l_session);
                            client_close_session_resp_sm (channel, l_session, resp_msg);
                            l_bret := TRUE
                        ELSE
                            /* Bad secure channel */
                            skip
                        END
                    ELSE
                        /* Session invalid state */
                        skip
                    END
                OR e_msg_session_cancel_resp THEN
                    /* Service not supported */
                    skip
                ELSE
                    /* Service unknown */
                    skip
                END
            END
        ELSE
            // Reponse error => session will be closed
            skip
        END;
        IF l_bret = FALSE THEN
            client_close_session_sm (session)
        END;
        session := l_session
    END
    ;
    
    session, service_ret <-- server_receive_session_req (channel, session_token, req_msg, req_typ, resp_msg) =
    VAR
        l_valid_session,
        l_session_state,
        l_session_channel,
        l_user,
        l_valid_user
    IN
        session := c_session_indet;
        service_ret := c_StatusCode_indet;
        CASE req_typ OF
            EITHER e_msg_session_create_req THEN
                // SESSION CREATION REQUEST
                session, service_ret <-- server_create_session_req_and_resp_sm (channel, req_msg, resp_msg)
            OR e_msg_session_activate_req THEN
                // SESSION ACTIVATION REQUEST
                // TODO: add a local operation for rest
                session <-- server_get_session_from_token (session_token);
                l_valid_session <-- is_valid_session (session);
                l_session_state <-- get_session_state_or_closed (session);
                IF l_valid_session = TRUE
                THEN
                    IF l_session_state = e_session_created or
                        l_session_state = e_session_userActivated or
                        l_session_state =  e_session_scOrphaned or
                        l_session_state = e_session_userActivated
                    THEN
                        l_user <-- read_activate_msg_user (req_msg);
                        l_valid_user <-- is_valid_user (l_user);
                        IF l_valid_user = TRUE
                        THEN
                            // TODO: differentiate sc_activate from user_activate directly here
                            service_ret <-- server_activate_session_req_and_resp_sm (channel, session, l_user, req_msg, resp_msg)
                        ELSE
                            // invalid user in msg => no session change
                            service_ret := e_sc_bad_identity_token_invalid
                        END;
                        IF service_ret /= e_sc_ok
                        THEN
                            // Invalid user or parameters in received request: choice is to close the session in this case (not specified)
                            server_close_session_sm (session)
                        END
                    ELSE
                        // if session is not in a correct state to be activated => close session
                        server_close_session_sm (session);
                        service_ret := e_sc_bad_invalid_state
                    END
                ELSE
                    // session token was not correct
                    service_ret := e_sc_bad_session_id_invalid
                END
            OR e_msg_session_close_req THEN
                // SESSION CLOSE REQUEST
                // TODO: add a local operation for rest
                session <-- server_get_session_from_token (session_token);
                l_valid_session <-- is_valid_session (session);
                l_session_state <-- get_session_state_or_closed (session);
                IF l_valid_session = TRUE
                THEN
                    IF l_session_state = e_session_created or
                        l_session_state = e_session_userActivating or
                        l_session_state = e_session_userActivated
                    THEN
                        l_session_channel <-- get_session_channel (session);
                        IF l_session_channel = channel
                        THEN
                            // TODO: respond to pending requests with error if close succeeded ?
                            service_ret <-- server_close_session_req_and_resp_sm (channel, session, req_msg, resp_msg)
                        ELSE
                            // Close anyway since incorrect channel usage is unexpected
                            server_close_session_sm (session);
                            // Use closest error code corresponding for response
                            service_ret := e_sc_bad_secure_channel_id_invalid
                        END
                    ELSE
                        // Close session and return error
                        server_close_session_sm (session);
                        service_ret := e_sc_bad_invalid_state
                    END
                ELSE
                    // session token was not correct => return error
                    service_ret := e_sc_bad_session_id_invalid
                END
            ELSE
                service_ret := e_sc_bad_service_unsupported
            END
        END
    END
    ;
    
    ret, channel, session_token <-- client_validate_session_service_req (session, req_handle) =
    VAR
        l_session_state,
        l_ret
    IN
        session_token := c_session_token_indet;
        channel := c_channel_indet;
        /* TODO: do not require req msg ? */
        l_session_state <-- get_session_state_or_closed (session); // l_session_state /= closed => is_valid_session = TRUE
        IF l_session_state = e_session_userActivated
        THEN
            session_token <-- client_get_token_from_session (session);
            channel <-- get_session_channel (session);
            client_add_session_request_handle (session, req_handle);
            l_ret := e_sc_ok
        ELSE
            l_ret := e_sc_bad_invalid_argument
        END;
        ret := l_ret
    END;
    
    bres, session <-- client_validate_session_service_resp (channel, req_handle) =
    VAR
        l_session,
        l_valid_session,
        l_session_state,
        l_session_channel
    IN  
        session := c_session_indet;
        l_session <-- client_get_session_and_remove_request_handle (req_handle);
        l_valid_session <-- is_valid_session (l_session);
        l_session_state <-- get_session_state_or_closed (l_session);
        IF l_valid_session = TRUE
        THEN
            l_session_channel <-- get_session_channel (l_session);
            IF l_session_state = e_session_userActivated &
                l_session_channel = channel
            THEN
                bres <-- is_session_valid_for_service (channel, l_session)
            ELSE
                bres := FALSE
            END;
            IF bres = FALSE
            THEN
                // session in invalid state or invalid channel used => close session
                client_close_session_sm (l_session)
            ELSE
                session := l_session
            END
        ELSE
            bres := FALSE
        END
    END;

    is_valid_res, session, status_code_err <-- server_validate_session_service_req (channel, req_handle, session_token) =
    VAR
        l_session,
        l_valid_session,
        l_session_state,
        l_session_channel
    IN
        // PRE validates req_handle valid
        req_handle_do_nothing(req_handle); // avoid warning
        l_session <-- server_get_session_from_token (session_token);
        l_valid_session <-- is_valid_session (l_session);
        l_session_state <-- get_session_state_or_closed (l_session);
        session := c_session_indet;
        IF l_valid_session = TRUE
        THEN
            l_session_channel <-- get_session_channel (l_session);
            IF l_session_state = e_session_userActivated &
                l_session_channel = channel
            THEN
                // Returns always TRUE if compliant with PRE (proved)
                is_valid_res <-- is_session_valid_for_service (channel, l_session);
                status_code_err := e_sc_ok;
                session := l_session
            ELSE
                // Unexpected access to session (wrong state or channel): close it
                server_close_session_sm (l_session);
                is_valid_res := FALSE;
                IF l_session_channel /= channel THEN
                    status_code_err := e_sc_bad_secure_channel_id_invalid
                ELSE
                    IF l_session_state =  e_session_created THEN
                        status_code_err := e_sc_bad_session_not_activated
                    ELSE
                        status_code_err := e_sc_bad_invalid_state
                    END
                END
            END
        ELSE
            is_valid_res := FALSE;
            status_code_err := e_sc_bad_session_id_invalid
        END
    END
    ;
    
    is_valid_res, status_code_err <-- server_validate_session_service_resp (channel, session, req_handle) =
    VAR
        l_valid_session,
        l_session_state,
        l_session_channel
    IN
        // PRE validates req_handle valid
        req_handle_do_nothing(req_handle); // avoid warning
        /* Coherency of messages types done in PRE for now */
        l_valid_session <-- is_valid_session (session);
        l_session_state <-- get_session_state_or_closed (session);
        IF l_valid_session = TRUE
        THEN
            l_session_channel <-- get_session_channel (session);
            IF l_session_state = e_session_userActivated &
                l_session_channel = channel
            THEN
                // Returns always TRUE if compliant with PRE (proved)
                is_valid_res <-- is_session_valid_for_service (channel, session);
                status_code_err := e_sc_ok
            ELSE
                is_valid_res := FALSE;
                IF l_session_channel = channel THEN
                    /* Invalid session state */
                    status_code_err := e_sc_bad_invalid_state
                ELSE
                    status_code_err := e_sc_bad_secure_channel_id_invalid
                END
            END
        ELSE
            is_valid_res := FALSE;
            status_code_err := e_sc_bad_session_id_invalid
        END
    END
    ;
    
    bret <-- client_create_session_req (session, channel, req_handle, create_req_msg) = 
    VAR
        l_valid_session,
        l_session_state,
        l_valid,
        l_bret
    IN
        l_bret := FALSE;
        l_valid_session <-- is_valid_session (session);
        l_session_state <-- get_session_state_or_closed (session);
        IF l_valid_session = TRUE
        THEN
            IF l_session_state = e_session_init
            THEN
                l_valid <-- client_create_session_req_sm (session, channel, create_req_msg);
                IF l_valid = TRUE THEN
                    client_add_session_request_handle (session, req_handle);
                    l_bret := TRUE
                ELSE
                    /* Create session request data failed */
                    skip
                END
            ELSE
                /* Session invalid state */
                skip
            END
        ELSE
            /* Session invalid */
            skip
        END;
        bret := l_bret
    END;
    
    bres <-- client_async_activate_new_session_without_channel (channel_config_idx, user) =
    VAR
        l_session,
        l_session_state
    IN
        l_session <-- client_init_session_sm;
	    l_session_state <-- get_session_state_or_closed (l_session); // Note: state != closed => session is valid
        IF l_session_state = e_session_init
        THEN
            bres := TRUE;
            /* channel did not exist or is not connected anymore: add async session creation on SC connection */
            set_session_to_create(l_session, channel_config_idx);
            set_session_to_activate(l_session, user)
        ELSE
            bres := FALSE
        END
    END
    ;

    bres <-- client_async_activate_new_session_with_channel (channel_config_idx, channel, user) =
    VAR
        l_session,
        l_session_state
    IN
        // PRE guarantee channel is connected
        channel_do_nothing(channel);
        l_session <-- client_init_session_sm;
        l_session_state <-- get_session_state_or_closed (l_session); // Note: state != closed => session is valid
        IF l_session_state = e_session_init
        THEN
            bres := TRUE;
            /* Generate event to create the session next and then waiting to be activated */
            client_gen_create_session_internal_event (l_session, channel_config_idx);
            set_session_to_activate(l_session, user)
        ELSE
            bres := FALSE
        END
    END
    ;
    
    ret, channel, session_token <-- client_user_activate_session_req (session, req_handle, user, activate_req_msg) =
    VAR
        l_valid_session,
        l_session_state,
        l_ret
    IN
        l_valid_session <-- is_valid_session (session);
        IF l_valid_session = TRUE
        THEN
            l_session_state <-- get_session_state_or_closed (session);
            IF l_session_state = e_session_created or
                l_session_state = e_session_userActivated
            THEN
                l_ret, channel, session_token <-- client_user_activate_session_req_sm (session, user, activate_req_msg);
                IF l_ret /= e_sc_ok
                THEN
                    /* Unexpected case: associated channel shall be connected for those session states */
                    client_close_session_sm (session);
                    l_ret := e_sc_bad_unexpected_error
                ELSE
                    IF l_ret = e_sc_ok
                    THEN
                        client_add_session_request_handle (session, req_handle)
                    ELSE
                        client_close_session_sm (session)
                    END
                END
            ELSE
                l_ret := e_sc_bad_invalid_state;
                channel := c_channel_indet;
                session_token := c_session_token_indet
            END
        ELSE
            l_ret := e_sc_bad_invalid_argument;
            channel := c_channel_indet;
            session_token := c_session_token_indet            
        END;
        ret := l_ret
    END
    ;
    
    ret, session_token <-- client_sc_activate_session_req (session , req_handle, channel, activate_req_msg) =
    VAR
        l_valid_session,
        l_session_state,
        l_ret
    IN
        l_valid_session <-- is_valid_session (session);
        IF l_valid_session = TRUE
        THEN
            l_session_state <-- get_session_state_or_closed (session);
            IF l_session_state = e_session_scOrphaned or 
                l_session_state = e_session_userActivated
            THEN
                session_token <-- client_sc_activate_session_req_sm (session , channel, activate_req_msg);
                client_add_session_request_handle (session, req_handle);
                l_ret := e_sc_ok
            ELSE
                l_ret := e_sc_bad_invalid_state;
                session_token := c_session_token_indet
            END
        ELSE
            l_ret := e_sc_bad_invalid_argument;
            session_token := c_session_token_indet
        END;
        ret := l_ret
    END
    ;
    
    client_channel_connected_event_session (channel_config_idx, channel) =
    BEGIN
        // PRE guarantee channel is connected
        channel_do_nothing(channel);
        // Associate sessions waiting for sc connection (orphaned or waiting for creation)
        local_sc_activate_sessions_on_SC_connection (channel_config_idx)
    END    
    ;
    
    ret, channel, session_token <-- client_close_session_req (session, req_handle, close_req_msg) =
    VAR
        l_valid_session,
        l_session_state,
        l_ret
    IN
        l_valid_session <-- is_valid_session(session);
        IF l_valid_session = TRUE
        THEN
            l_session_state <-- get_session_state_or_closed (session);
            IF l_session_state = e_session_created or
                l_session_state = e_session_userActivating or
                l_session_state = e_session_userActivated
            THEN
                l_ret, channel, session_token <-- client_close_session_req_sm (session, close_req_msg);
                IF l_ret /= e_sc_ok
                THEN
                    /* Unexpected case: associated channel shall be connected for those session states */
                    client_close_session_sm (session);
                    l_ret := e_sc_bad_unexpected_error
                END;
                IF l_ret = e_sc_ok
                THEN
                    client_add_session_request_handle (session, req_handle)
                END
            ELSE
                l_ret := e_sc_bad_invalid_state;
                channel := c_channel_indet;
                session_token := c_session_token_indet
            END
        ELSE
            l_ret := e_sc_bad_invalid_argument;
            channel := c_channel_indet;
            session_token := c_session_token_indet
        END;
        ret := l_ret
    END
    ;
    
    client_close_session (session) =
    BEGIN
        client_remove_all_request_handles (session);
        client_close_session_sm (session)
    END
 
END
