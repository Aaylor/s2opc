/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    subscription_core_i
REFINES
    subscription_core
    
SEES
    constants,
    message_in_bs,
    message_out_bs,
    request_handle_bs
    
IMPORTS
    subscription_core_1,
    subscription_core_bs,
    subscription_core_it,
    monitored_item_notification_queue_bs,
    monitored_item_queue_bs,
    monitored_item_pointer_bs,
    publish_request_queue_bs,
    msg_subscription_publish_bs
    
PROMOTES
    /* subscription_core_1 */
    is_valid_subscription,
    remove_subscription_session,
    getall_subscription,
    /* subscription_core_bs */
    compute_create_subscription_revised_params,
    get_nodeToMonitoredItemQueue,
    /* monitored_item_pointer_bs*/
    is_notification_triggered,
    getall_monitoredItemPointer,
    /* msg_subscription_publish_bs */
    get_msg_header_expiration_time,
    set_msg_publish_resp_subscription,
    set_msg_publish_resp_notificationMsg,
    generate_internal_send_publish_response_event
    
    
LOCAL_OPERATIONS
    
    bres, p_subscription <-- get_fresh_subscription =
    BEGIN
        IF t_subscription = s_subscription
        THEN
            bres := FALSE ||
            p_subscription := c_subscription_indet
        ELSE
            ANY l_subscription WHERE
                l_subscription : t_subscription - s_subscription
            THEN
                bres := TRUE ||
                p_subscription := l_subscription
            END
        END
    END
    ;
    
    /* - Pop the expired publish requests and generate an event to send a Bad_Timeout response
    - Check if a valid (non expired) publish request is available 
    */
    p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_subscription) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription
    THEN
        LET l_pubReqQueue BE
            l_pubReqQueue = a_publishRequestQueue (p_subscription)
        IN
            IF #msg.(msg : a_publish_responses~[{l_pubReqQueue}] & a_publish_expiration_time (msg) /: s_expired_time_ref)
            THEN
                /* If a non expired publish request exists: 
                   - a valid publish request is enqueued
                   - we may have popped expired publish requests from the queue (and generated timeout response event)
                */
                validPublishReqQueued := TRUE ||
                p_validPubReqQueued := TRUE ||
                a_publish_responses 
                :(a_publish_responses : t_msg +-> t_publishReqQueue &
                  a_publish_responses |>> {l_pubReqQueue} = a_publish_responses$0 |>> {l_pubReqQueue} &
                  card((a_publish_responses$0 |> {l_pubReqQueue}) - (a_publish_responses |> {l_pubReqQueue})) >= 0
                 )
            ELSE
                validPublishReqQueued := FALSE ||
                p_validPubReqQueued := FALSE
            END
        END
    END
    ;
    
    fill_notification_message (p_queue, p_notif_msg, nb_notif_to_dequeue) =
    PRE
        p_queue : t_notificationQueue_i &
        p_queue : t_notificationQueue &
        p_notif_msg : t_notif_msg_i &
        p_notif_msg : t_notif_msg &
        notification_message = p_notif_msg &
        nb_notif_to_dequeue : NAT &
        nb_notif_to_dequeue : t_monitoredItemNotifIndex &
        nb_notif_to_dequeue = nb_monitored_item_notifications &
        nb_notif_to_dequeue <= card(a_monitored_item_notifications[{p_queue}])
    THEN
        ANY l_a_monitored_item_notifications_dequeued WHERE
            l_a_monitored_item_notifications_dequeued <: a_monitored_item_notifications & /* Set of dequeued notifications */
            dom(l_a_monitored_item_notifications_dequeued) = {p_queue} & /* Only notification of the current queue */
            card(l_a_monitored_item_notifications_dequeued) = nb_monitored_item_notifications /* Expected number of notification dequeued*/
        THEN
            MonitoredItemNotification_MonitoredItemId
            :(MonitoredItemNotification_MonitoredItemId : t_monitoredItemNotifIndex +-> t_monitoredItemId &
              dom(MonitoredItemNotification_MonitoredItemId) = 1..nb_monitored_item_notifications & /*  */
              ran(MonitoredItemNotification_MonitoredItemId) = a_monitoredItemId[l_a_monitored_item_notifications_dequeued[{p_queue}]]) ||
            a_monitored_item_notifications := a_monitored_item_notifications - l_a_monitored_item_notifications_dequeued
        END
    END
    
OPERATIONS
    /* LOCAL OPERATIONS */
    
    bres, p_subscription <-- get_fresh_subscription =
    VAR
        l_subscription,
        l_is_subscription,
        l_continue
    IN
        bres := FALSE;
        p_subscription := c_subscription_indet;
        l_subscription := c_subscription_indet;
        l_is_subscription := TRUE;
        l_continue <-- init_iter_subscription;
        IF  l_continue = TRUE  /* Only for the proof */
        THEN
            WHILE
                l_continue   = TRUE &
                l_is_subscription = TRUE
            DO
                l_continue, l_subscription <-- continue_iter_subscription;
                l_is_subscription <-- is_valid_subscription(l_subscription)
            INVARIANT
                l_continue = bool(subscriptions_to_iterate /= {}) &
                subscriptions_to_iterate /\ subscriptions_iterated = {} &
                subscriptions_to_iterate \/ subscriptions_iterated = t_subscription &
                (   l_is_subscription = TRUE
                    =>
                    subscriptions_iterated <: s_subscription) &
                (   l_is_subscription = FALSE
                    =>
                    l_subscription  : t_subscription &
                    l_subscription /: s_subscription)
            VARIANT
                card(subscriptions_to_iterate)
            END
        END;
        IF l_is_subscription = FALSE
        THEN
            bres := TRUE;
            p_subscription := l_subscription
        END
    END
    ;
    
    p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_subscription) =
    VAR
        l_pubReqQueue,
        l_continue,
        l_session, 
        l_req_exp_time, 
        l_req_handle, 
        l_req_ctx, 
        l_resp_msg,
        l_is_expired
    IN
        p_validPubReqQueued := FALSE;
        l_pubReqQueue <-- get_subscription_publishRequestQueue (p_subscription);
        l_continue <-- init_iter_publish_request (l_pubReqQueue);
        l_is_expired := TRUE;
        WHILE l_continue = TRUE & l_is_expired = TRUE DO
            l_continue, l_session, l_req_exp_time, l_req_handle, l_req_ctx, l_resp_msg 
              <-- continue_pop_head_iter_publish_request (l_pubReqQueue);
            l_is_expired <-- is_request_expired (l_req_exp_time);
            IF l_is_expired = TRUE
            THEN
                generate_internal_send_publish_response_event (l_session, l_resp_msg, l_req_handle, l_req_ctx, e_sc_bad_timeout)
            ELSE
                /* Next publish request is a valid (non expired) one, prepend it for next pop on queue */
                p_validPubReqQueued <-- prepend_publish_request_to_queue 
                  (l_pubReqQueue, l_session, l_req_exp_time, l_req_handle, l_req_ctx, l_resp_msg)
            END
        INVARIANT
            l_continue = bool(a_publish_responses~[{l_pubReqQueue}] /= {})

        VARIANT
            card(a_publish_responses~[{l_pubReqQueue}])
        END
    END
    ;
    
    fill_notification_message (p_queue, p_notif_msg, nb_notif_to_dequeue) =
    VAR
        l_index,
        l_continue,
        l_monitoredItem, 
        l_writeValuePointer,
        
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle 
    IN
        l_index := 1;
        WHILE l_index <= nb_notif_to_dequeue DO
            l_continue, l_monitoredItem, l_writeValuePointer <-- continue_pop_iter_monitor_item_notification (p_queue);
            /* Retrieve monitoredItem Id + client handle */
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle 
              <--getall_monitoredItemPointer (l_monitoredItem);

            setall_notification_msg_monitored_item_notif (p_notif_msg, l_index, l_monitoredItemId, l_clientHandle, l_writeValuePointer);
            l_index := l_index + 1
        INVARIANT
            dom(MonitoredItemNotification_MonitoredItemId) = 1..l_index &
            {p_queue} <<| a_monitored_item_notifications = {p_queue} <<| a_monitored_item_notifications$0 &
            {p_queue} <| a_monitored_item_notifications <: {p_queue} <| a_monitored_item_notifications$0 &
            card({p_queue} <| a_monitored_item_notifications) = card({p_queue} <| a_monitored_item_notifications$0) - l_index
        VARIANT
            (nb_notif_to_dequeue - l_index) /* notifications to add */
            /* OR card(a_monitored_item_notifications[{p_queue}]) deleted notifications */
        END
    END
    ;
    
    /* END OF LOCAL OPERATIONS */
    
    is_valid <-- is_valid_subscription_on_session (p_session, p_subscription) =
    VAR
        l_dom,
        l_sub
    IN
        l_dom, l_sub <-- getall_subscription (p_session);
        is_valid := bool(l_dom = TRUE & p_subscription = l_sub)
    END
    ;
    
    empty_session_publish_requests (p_subscription) =
    VAR
        l_PublishRequestQueue
    IN
        l_PublishRequestQueue <-- get_subscription_publishRequestQueue (p_subscription);
        clear_publish_queue (l_PublishRequestQueue)
    END
    ;

    StatusCode_service, subscription <-- create_subscription (p_session,
                                                              p_revPublishInterval,
                                                              p_revLifetimeCount,
                                                              p_revMaxKeepAlive,
                                                              p_maxNotificationsPerPublish,
                                                              p_publishEnabled) =
    VAR
        l_bres,
        l_subscription,
        l_bres_notif,
        l_newNotifQueue,
        l_bres_pub,
        l_newPublishQueue,
        l_bres_monitored,
        l_newMonitoredItemQueue,
        l_bres_timer,
        l_timerId
    IN
        StatusCode_service := c_StatusCode_indet;
        subscription := c_subscription_indet;
        l_bres, l_subscription <-- get_fresh_subscription;

        IF l_bres = TRUE
        THEN
            l_bres_notif, l_newNotifQueue <-- allocate_new_monitored_item_notification_queue;
            l_bres_pub, l_newPublishQueue <-- allocate_new_publish_queue;
            l_bres_monitored, l_newMonitoredItemQueue <-- allocate_new_monitored_item_queue;
            l_bres_timer, l_timerId <-- create_publish_timer (l_subscription, p_revPublishInterval);
            IF l_bres_notif = TRUE & l_bres_pub = TRUE & l_bres_monitored = TRUE & l_bres_timer = TRUE
            THEN
                StatusCode_service := e_sc_ok;
                add_subscription (l_subscription,
                                  p_session,
                                  p_revPublishInterval,
                                  p_revLifetimeCount,
                                  p_revMaxKeepAlive,
                                  p_maxNotificationsPerPublish,
                                  p_publishEnabled,
                                  l_newNotifQueue,
                                  l_newPublishQueue,
                                  l_newMonitoredItemQueue,
                                  l_timerId);
                subscription := l_subscription
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory;
                IF l_bres_notif = TRUE
                THEN
                    clear_and_deallocate_monitored_item_notification_queue (l_newNotifQueue)
                END;
                IF l_bres_pub = TRUE
                THEN
                    clear_and_deallocate_publish_queue (l_newPublishQueue)
                END;
                IF l_bres_monitored = TRUE
                THEN
                    clear_and_deallocate_monitored_item_queue (l_newMonitoredItemQueue)
                END
                ;
                IF l_bres_timer = TRUE
                THEN
                    delete_publish_timer (l_timerId)
                END
            END
        ELSE
            StatusCode_service := e_sc_bad_too_many_subscriptions
        END
    END
    ;
    
    close_subscription (p_subscription) =
    VAR
        l_timer_id,
        l_publish_queue,
        l_monitored_item_queue
    IN
        l_timer_id <-- get_subscription_timer_id (p_subscription);
        delete_publish_timer (l_timer_id);
        l_publish_queue <-- get_subscription_publishRequestQueue (p_subscription);
        clear_and_deallocate_publish_queue (l_publish_queue);
        /* TODO: iter on monitored items and remove them from node queues ! */
        l_monitored_item_queue <-- get_subscription_monitoredItemQueue (p_subscription);
        clear_and_deallocate_monitored_item_queue (l_monitored_item_queue);
        delete_subscription (p_subscription)
    END
    ;
    
    StatusCode_service, async_resp_msg, subscription, moreNotifs
      <-- receive_publish_request (p_session, p_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg) =
    VAR
        l_dom,
        l_subscription,
        l_subscriptionState,
        l_PublishingReqQueue,
        l_PublishingEnabled,
        l_NotificationQueue,
        l_nb_notifications,
        l_NotificationAvailable,
        l_MoreNotifications,
        
        l_bres,
        l_notifMsg,
        l_seq_num,
        l_next_seq_num
    IN
        l_dom, l_subscription <-- getall_subscription (p_session); /* l_dom = TRUE already verified by caller */
        l_subscriptionState <-- get_subscription_state (l_subscription);
        l_PublishingReqQueue <-- get_subscription_publishRequestQueue (l_subscription);
        l_PublishingEnabled <-- get_subscription_PublishingEnabled (l_subscription);
        l_MoreNotifications <-- get_subscription_MoreNotifications (l_subscription);
        l_NotificationQueue <-- get_subscription_notificationQueue (l_subscription);
        l_nb_notifications <-- init_iter_monitored_item_notification (l_NotificationQueue);
        l_NotificationAvailable := bool(l_nb_notifications > 0);
        
        moreNotifs := FALSE;
        subscription := c_subscription_indet;
        
        /* #4 transition */
        IF l_subscriptionState = e_subscriptionState_normal &
           (l_PublishingEnabled = FALSE
            or
            (l_PublishingEnabled = TRUE &
             l_MoreNotifications = FALSE)
           )
        THEN
            l_bres <-- append_publish_request_to_queue (l_PublishingReqQueue, p_session, p_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg);
            IF l_bres = TRUE
            THEN
                StatusCode_service := e_sc_ok;
                async_resp_msg := TRUE
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory;
                async_resp_msg := FALSE
            END
        /* #5 transition */
        ELSIF l_subscriptionState = e_subscriptionState_normal &
              l_PublishingEnabled = TRUE & l_MoreNotifications = TRUE
        THEN
            subscription := l_subscription;
            async_resp_msg := FALSE;
            
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (l_subscription);
            
            /* retrieve notification number */
            IF l_nb_notifications > k_n_monitoredItemNotif_max
            THEN
                l_nb_notifications := k_n_monitoredItemNotif_max;
                moreNotifs := TRUE
            END
            ;
            
            /* allocate and fill notification "message" */
            l_bres, l_notifMsg <-- alloc_notification_message_items (p_resp_msg, l_nb_notifications);
            IF l_bres = TRUE
            THEN
                /* Manage sequence number */
                l_seq_num <-- get_subscription_SeqNum (l_subscription);
                set_notification_message_sequence_number (l_notifMsg, l_seq_num);
                l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
                set_subscription_SeqNum (l_subscription, l_next_seq_num);
                
                /* Fill notification message */
                fill_notification_message (l_NotificationQueue, l_notifMsg, l_nb_notifications);
                StatusCode_service := e_sc_ok
            ELSE
                moreNotifs := TRUE;
                StatusCode_service := e_sc_bad_out_of_memory
            END;
            set_subscription_MoreNotifications (l_subscription, moreNotifs);
            set_subscription_MessageSent (l_subscription)

        /* #10 transition */
        ELSIF l_subscriptionState = e_subscriptionState_late &
              l_PublishingEnabled = TRUE &
              (l_MoreNotifications = TRUE or l_NotificationAvailable = TRUE)
        THEN
            set_subscription_state (l_subscription, e_subscriptionState_normal);
            subscription := l_subscription;
            async_resp_msg := FALSE;
            
            /* Note: Idem previous transition below: */

            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (l_subscription);
            
            /* retrieve notification number */
            IF l_nb_notifications > k_n_monitoredItemNotif_max
            THEN
                l_nb_notifications := k_n_monitoredItemNotif_max;
                moreNotifs := TRUE
            END
            ;
            
            /* allocate and fill notification "message" */
            l_bres, l_notifMsg <-- alloc_notification_message_items (p_resp_msg, l_nb_notifications);
            IF l_bres = TRUE
            THEN
                /* Manage sequence number */
                l_seq_num <-- get_subscription_SeqNum (l_subscription);
                set_notification_message_sequence_number (l_notifMsg, l_seq_num);
                l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
                set_subscription_SeqNum (l_subscription, l_next_seq_num);
                
                /* Fill notification message */
                fill_notification_message (l_NotificationQueue, l_notifMsg, l_nb_notifications);
                StatusCode_service := e_sc_ok
            ELSE
                moreNotifs := TRUE;
                StatusCode_service := e_sc_bad_out_of_memory
            END;
            set_subscription_MoreNotifications (l_subscription, moreNotifs);
            set_subscription_MessageSent (l_subscription)

        /* #11 transition */
        ELSIF l_subscriptionState = e_subscriptionState_late &
             (l_PublishingEnabled = FALSE
              or  
              (l_PublishingEnabled = TRUE &
               l_NotificationAvailable = FALSE &
               l_MoreNotifications = FALSE)               
             )
        THEN
            set_subscription_state (l_subscription, e_subscriptionState_keepAlive);
            subscription := l_subscription;
            async_resp_msg := FALSE;
            
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (l_subscription);
            
            /* prepare a keep alive message content */
            StatusCode_service := e_sc_ok;
            /* get and fill notification "message" */
            l_notifMsg <-- get_notification_message_no_items (p_resp_msg);
            /* Get sequence number of next message to be sent (do not increment it for keep alive) */
            l_seq_num <-- get_subscription_SeqNum (l_subscription);
            set_notification_message_sequence_number (l_notifMsg, l_seq_num);
            set_subscription_MessageSent (l_subscription)
            
        /* #13 transition */
        ELSIF l_subscriptionState = e_subscriptionState_keepAlive
        THEN
            l_bres <-- append_publish_request_to_queue (l_PublishingReqQueue, p_session, p_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg);
            IF l_bres = TRUE
            THEN
                StatusCode_service := e_sc_ok;
                async_resp_msg := TRUE
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory;
                async_resp_msg := FALSE
            END
        ELSE
            subscription := l_subscription;
            StatusCode_service := e_sc_bad_invalid_state;
            async_resp_msg := FALSE
            
        END
    END
    ;
    
    revisedSamplingItv, revisedQueueSize <-- compute_create_montitored_item_revised_params (p_reqQueueSize) =
    BEGIN
        revisedSamplingItv := c_opcua_duration_zero;
        revisedQueueSize := p_reqQueueSize
    END
    ;

    StatusCode_service, monitoredItemPointer, monitoredItemId <-- create_monitored_item (p_subscription,
                                                                                         p_nid,
                                                                                         p_aid,
                                                                                         p_value,
                                                                                         p_valueSc,
                                                                                         p_timestampToReturn,
                                                                                         p_monitoringMode,
                                                                                         p_clientHandle) =
    VAR
        l_bres,
        l_sub_monitIt_queue,
        l_node_monitIt_queue,
        l_sub_notif_queue
    IN
        StatusCode_service := e_sc_bad_too_many_monitored_items;
        /* Create monitored item */
        l_bres, monitoredItemPointer, monitoredItemId
          <-- create_monitored_item_pointer(p_subscription,
                                            p_nid,
                                            p_aid,
                                            p_timestampToReturn,
                                            p_monitoringMode,
                                            p_clientHandle);
        IF l_bres = TRUE
        THEN
            l_node_monitIt_queue <-- get_nodeToMonitoredItemQueue (p_nid);
            l_sub_monitIt_queue <-- get_subscription_monitoredItemQueue (p_subscription);
            l_bres <-- add_monitored_item_to_queue (l_node_monitIt_queue, monitoredItemPointer);
            IF l_bres = TRUE
            THEN
                /* Add monitored item to subscription and node queues */
                l_bres <-- add_monitored_item_to_queue (l_sub_monitIt_queue, monitoredItemPointer);
                IF l_bres = FALSE
                THEN
                    l_bres <-- remove_monitored_item (l_node_monitIt_queue, monitoredItemPointer);
                    l_bres := FALSE
                END
            END
            ;
            IF l_bres = TRUE
            THEN
                /* Generate a notification for new monitored item */
                l_sub_notif_queue <-- get_subscription_notificationQueue (p_subscription);
                l_bres <-- add_first_monitored_item_notification_to_queue (l_sub_notif_queue, 
                                                                           monitoredItemPointer, 
                                                                           p_nid,
                                                                           p_aid,
                                                                           p_value,
                                                                           p_valueSc);
                IF l_bres = FALSE
                THEN
                    l_bres <-- remove_monitored_item (l_node_monitIt_queue, monitoredItemPointer);
                    l_bres <-- remove_monitored_item (l_sub_monitIt_queue, monitoredItemPointer);
                    l_bres := FALSE
                ELSE
                    StatusCode_service := e_sc_ok
                END                                                    
            END
        END
    END
    ;
    
    p_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_subscription) =
    BEGIN
        p_validPublishingReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_subscription)
    END
    ;
    
    p_close_sub, p_msg_to_send, p_session, p_publish_resp_msg, p_req_handle, p_req_context, p_validPubReqQueued
      <-- server_subscription_core_publish_timeout_check_lifetime (p_subscription) =
    VAR
        l_lifetimeCounter
    IN
        /* #27 transition evaluation */
        p_close_sub := FALSE;
        p_msg_to_send := FALSE;
        p_session := c_session_indet;
        p_publish_resp_msg := c_msg_indet;
        p_req_handle := c_server_request_handle_any;
        p_req_context := c_request_context_indet;
        
        p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_subscription);
        IF p_validPubReqQueued = FALSE
        THEN
            l_lifetimeCounter <-- get_subscription_LifetimeCounter (p_subscription);
            IF l_lifetimeCounter <= 1
            THEN
                p_close_sub := TRUE
            ELSE
                decrement_subscription_LifetimeCounter (p_subscription)
            END
     /* ELSE: Since some valid publishing requests are available nothing to do */
        END
    END
    ;
        
    p_msg_to_send, p_msg_sc, p_session, p_publish_resp_msg, p_req_handle, p_req_context, p_moreNotifs
      <-- server_subscription_core_publish_timeout (p_subscription, p_validPublishReqQueued) =
    VAR
        l_pubInterval,
        l_newTimerId,
        l_bres,
        l_State,
        l_PublishingReqQueue,
        l_PublishingEnabled,
        l_NotificationQueue,
        l_nb_notifications,
        l_NotificationAvailable,
        l_MessageSent,
        l_KeepAliveCounter,
        
        l_notifMsg,
        l_req_exp_time,
        l_seq_num,
        l_next_seq_num
    IN
        p_msg_to_send := FALSE;
        p_session := c_session_indet;
        p_publish_resp_msg := c_msg_indet;
        p_req_handle := c_server_request_handle_any;
        p_req_context := c_request_context_indet;
        p_moreNotifs := FALSE;
        p_msg_sc := c_StatusCode_indet;
        
        /* Restart timer */
        l_pubInterval <-- get_subscription_publishInterval (p_subscription);
        l_bres, l_newTimerId <-- create_publish_timer (p_subscription, l_pubInterval);
        IF l_bres = TRUE
        THEN
            set_subscription_timer_id (p_subscription, l_newTimerId)
        END;
        /* TODO : manage l_bres = FALSE */
        
        /* Retrieve state variables */
        l_State <-- get_subscription_state (p_subscription);
        l_PublishingReqQueue <-- get_subscription_publishRequestQueue (p_subscription);
        l_PublishingEnabled <-- get_subscription_PublishingEnabled (p_subscription);
        l_NotificationQueue <-- get_subscription_notificationQueue (p_subscription);
        l_nb_notifications <-- init_iter_monitored_item_notification (l_NotificationQueue);
        l_NotificationAvailable := bool(l_nb_notifications > 0);
        l_MessageSent <-- get_subscription_MessageSent (p_subscription);
        l_KeepAliveCounter <-- get_subscription_KeepAliveCounter (p_subscription);
        
        /* #6 transition */
        IF l_State = e_subscriptionState_normal &
            p_validPublishReqQueued = TRUE &
            l_PublishingEnabled = TRUE &
            l_NotificationAvailable = TRUE
        THEN
            /* Note: same treatment as #14 below ! */
            
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);
            /* retrieve a valid publish response */
            p_session, l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg <-- pop_head_publish_request_queue (l_PublishingReqQueue);
            /* retrieve notification number */
            IF l_nb_notifications > k_n_monitoredItemNotif_max
            THEN
                l_nb_notifications := k_n_monitoredItemNotif_max;
                p_moreNotifs := TRUE
            END
            ;
            /* allocate and fill notification "message" */
            l_bres, l_notifMsg <-- alloc_notification_message_items (p_publish_resp_msg, l_nb_notifications);
            IF l_bres = TRUE
            THEN
                /* Manage sequence number */
                l_seq_num <-- get_subscription_SeqNum (p_subscription);
                set_notification_message_sequence_number (l_notifMsg, l_seq_num);
                l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
                set_subscription_SeqNum (p_subscription, l_next_seq_num);
                
                /* Fill notification message */
                fill_notification_message (l_NotificationQueue, l_notifMsg, l_nb_notifications);
                p_msg_sc := e_sc_ok
            ELSE
                p_moreNotifs := TRUE;
                p_msg_sc := e_sc_bad_out_of_memory
            END;
            set_subscription_MoreNotifications (p_subscription, p_moreNotifs);
            set_subscription_MessageSent (p_subscription)
        /* #7 transition */
        ELSIF l_State = e_subscriptionState_normal &
              p_validPublishReqQueued = TRUE &
              l_MessageSent = FALSE &
              (l_PublishingEnabled = FALSE or
                (l_PublishingEnabled = TRUE &
                 l_NotificationAvailable = FALSE)
              )
        THEN 
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);
            /* retrieve a valid publish response */
            p_session, l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_head_publish_request_queue (l_PublishingReqQueue);
            set_publish_response_msg (p_publish_resp_msg);
            
            /* Note: same treatment as #15 below ! */
            
            /* prepare a keep alive message content */
            p_msg_sc := e_sc_ok;
            p_moreNotifs := FALSE;
            /* get and fill notification "message" */
            l_notifMsg <-- get_notification_message_no_items (p_publish_resp_msg);
            /* Get sequence number of next message to be sent (do not increment it for keep alive) */
            l_seq_num <-- get_subscription_SeqNum (p_subscription);
            set_notification_message_sequence_number (l_notifMsg, l_seq_num);
            set_subscription_MessageSent (p_subscription)
            
        /* #8 transition */
        ELSIF l_State = e_subscriptionState_normal &
              p_validPublishReqQueued = FALSE &
              (l_MessageSent = FALSE 
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = TRUE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_late)
            
        /* #9 transition */
        ELSIF l_State = e_subscriptionState_normal &
              l_MessageSent = TRUE &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = TRUE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_keepAlive);
            reset_subscription_KeepAliveCounter (p_subscription)
            
        /* #12 transition */
        ELSIF l_State = e_subscriptionState_late
        THEN
            skip /* Nothing to do: lifetime already checked */
        /* #14 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              l_PublishingEnabled = TRUE &
              l_NotificationAvailable = TRUE &
              p_validPublishReqQueued = TRUE
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_normal);
            
            /* Note: same treatment as #7 below ! */
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);
            
            /* retrieve a valid publish response */
            p_session, l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_head_publish_request_queue (l_PublishingReqQueue);
            
            /* retrieve notification number */
            IF l_nb_notifications > k_n_monitoredItemNotif_max
            THEN
                l_nb_notifications := k_n_monitoredItemNotif_max;
                p_moreNotifs := TRUE
            END
            ;
            /* allocate and fill notification "message" */
            l_bres, l_notifMsg <-- alloc_notification_message_items (p_publish_resp_msg, l_nb_notifications);
            IF l_bres = TRUE
            THEN
                /* Manage sequence number */
                l_seq_num <-- get_subscription_SeqNum (p_subscription);
                set_notification_message_sequence_number (l_notifMsg, l_seq_num);
                l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
                set_subscription_SeqNum (p_subscription, l_next_seq_num);
                
                /* Fill notification message */
                fill_notification_message (l_NotificationQueue, l_notifMsg, l_nb_notifications);
                p_msg_sc := e_sc_ok
            ELSE
                p_moreNotifs := TRUE;
                p_msg_sc := e_sc_bad_out_of_memory
            END;
            set_subscription_MoreNotifications (p_subscription, p_moreNotifs);
            set_subscription_MessageSent (p_subscription)

        /* #15 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              p_validPublishReqQueued = TRUE &
              l_KeepAliveCounter = 1 &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = FALSE)
              )
        THEN
            reset_subscription_KeepAliveCounter (p_subscription);
            
            /* Note: same treatment as #7 below ! */
            /* retrieve a valid publish response */
            p_session, l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_head_publish_request_queue (l_PublishingReqQueue);
            set_publish_response_msg (p_publish_resp_msg);

            /* prepare a keep alive message content */
            p_msg_sc := e_sc_ok;
            p_moreNotifs := FALSE;
            /* get and fill notification "message" */
            l_notifMsg <-- get_notification_message_no_items (p_publish_resp_msg);
            /* Get sequence number of next message to be sent (do not increment it for keep alive) */
            l_seq_num <-- get_subscription_SeqNum (p_subscription);
            set_notification_message_sequence_number (l_notifMsg, l_seq_num)
            
        /* #16 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              l_KeepAliveCounter > 1 &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = FALSE)
              )
        THEN
            decrement_subscription_KeepAliveCounter (p_subscription)

        /* #17 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              p_validPublishReqQueued = FALSE &
              (l_KeepAliveCounter = 1
               or
               (l_KeepAliveCounter > 1 &
                l_PublishingEnabled = TRUE &
                l_NotificationAvailable = TRUE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_late)
        ELSE
            skip
            /* TODO: invalid state evaluation: generate log error trace */
        END
    END
    ;
    
    p_msg_to_send, p_msg_sc, p_session, p_publish_resp_msg, p_req_handle, p_req_context, p_moreNotifs
      <-- server_subscription_core_publish_timeout_return_moreNotifs (p_subscription) =
    VAR
        l_req_exp_time,
        l_PublishingReqQueue,
        l_nb_notifications,
        l_bres,
        l_notifMsg,
        l_seq_num,
        l_next_seq_num,
        l_NotificationQueue
    IN
        p_moreNotifs := FALSE;
        p_msg_to_send := TRUE;
        l_PublishingReqQueue <-- get_subscription_publishRequestQueue (p_subscription);
        l_NotificationQueue <-- get_subscription_notificationQueue (p_subscription);
        l_nb_notifications <-- init_iter_monitored_item_notification (l_NotificationQueue);
          
        /* retrieve a valid publish response */
        p_session, l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
          <-- pop_head_publish_request_queue (l_PublishingReqQueue);
            
        /* retrieve notification number */
        IF l_nb_notifications > k_n_monitoredItemNotif_max
        THEN
            l_nb_notifications := k_n_monitoredItemNotif_max;
            p_moreNotifs := TRUE
        END
        ;
        /* allocate and fill notification "message" */
        l_bres, l_notifMsg <-- alloc_notification_message_items (p_publish_resp_msg, l_nb_notifications);
        IF l_bres = TRUE
        THEN
            /* Manage sequence number */
            l_seq_num <-- get_subscription_SeqNum (p_subscription);
            set_notification_message_sequence_number (l_notifMsg, l_seq_num);
            l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
            set_subscription_SeqNum (p_subscription, l_next_seq_num);
            
            /* Fill notification message */
            fill_notification_message (l_NotificationQueue, l_notifMsg, l_nb_notifications);
            p_msg_sc := e_sc_ok
        ELSE
            p_moreNotifs := TRUE;
            p_msg_sc := e_sc_bad_out_of_memory
        END;
        set_subscription_MoreNotifications (p_subscription, p_moreNotifs)
    END
    ;
    
    server_subscription_add_notification (p_subscription, p_monitoredItemPointer, p_writeValuePointer) =
    VAR
        l_notif_queue,
        l_res
    IN
        l_notif_queue <-- get_subscription_notificationQueue (p_subscription);
        l_res <-- add_monitored_item_notification_to_queue (l_notif_queue, p_monitoredItemPointer, p_writeValuePointer)
        /* TODO: manage l_res == FALSE*/
    END

END
