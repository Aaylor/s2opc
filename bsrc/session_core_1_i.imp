/*
 *  Copyright (C) 2018 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    session_core_1_i

REFINES
    session_core_1

SEES
    constants,
    request_handle_bs,
    message_out_bs,
    message_in_bs,
    channel_mgr

IMPORTS
    session_core_1_it,
    session_core_2,
    session_core_bs

PROMOTES
    server_get_session_from_token,
    client_get_token_from_session,
    server_get_fresh_session_token,
    server_is_valid_session_token,
    client_set_session_token,
    reset_session_to_create,
    is_valid_session,
    get_session_state,
    set_session_channel,
    getall_session_channel,
    get_session_channel,
    getall_to_create,
    getall_orphaned,
    set_session_to_create,
    is_valid_user, /* TODO FBA devrait être déplacée dans constants.mch VMO: pour l'instant laisser là pour le C */
    set_session_user,
    get_session_user,
    server_create_session_req_do_crypto,
    client_activate_session_req_do_crypto,
    get_NonceServer,
    client_create_session_req_do_crypto,
    get_NonceClient,
    drop_NonceClient,
    client_create_session_check_crypto,
    server_activate_session_check_crypto,
    client_activate_session_resp_check,
    client_close_session_req_msg,
    client_close_session_resp_msg,
    server_close_session_check_req,
    session_do_nothing,
    set_session_to_activate,
    getall_to_activate,
    reset_session_to_activate,
    client_gen_create_session_internal_event,
    client_gen_activate_orphaned_session_internal_event,
    client_gen_activate_user_session_internal_event,
    server_session_timeout_start_timer,
    server_session_timeout_evaluation,
    server_session_timeout_msg_received

LOCAL_OPERATIONS

    l_set_session_state(p_session, p_state) =
    PRE
        p_session : t_session_i    &
        p_session : dom(a_state)   &
        p_state   : t_sessionState &
        p_state  /= e_session_closed
    THEN
        a_state(p_session) := p_state
    END

OPERATIONS
   
    /* Local operations */

    l_set_session_state(p_session, p_state) =
    VAR
        l_prec_state
    IN
        l_prec_state <-- get_session_state(p_session);
        set_session_state_1(p_session, p_state);
        notify_set_session_state(p_session, l_prec_state, p_state)
    END
    ;


    /* Global operations */

    p_session <-- init_new_session =
    VAR
        l_is_session,
        l_continue
    IN
        p_session := c_session_indet;
        l_is_session := TRUE;
        l_continue <-- init_iter_session;
        IF  l_continue = TRUE  /* Only for the proof */
        THEN
            WHILE
                l_continue   = TRUE &
                l_is_session = TRUE
            DO
                l_continue, p_session <-- continue_iter_session;
                l_is_session <-- is_valid_session(p_session)
            INVARIANT
                l_continue = bool(sessions_to_iterate /= {}) &
                sessions_to_iterate /\ sessions_iterated = {} &
                sessions_to_iterate \/ sessions_iterated = t_session &
                (   l_is_session = TRUE
                    =>
                    sessions_iterated <: s_session) &
                (   l_is_session = FALSE
                    =>
                    p_session  : t_session &
                    p_session /: s_session)
            VARIANT
                card(sessions_to_iterate)
            END
        END;
        IF  l_is_session = TRUE THEN
            p_session := c_session_indet
        ELSE
            add_session(p_session, e_session_init)
        END
    END
    ;

    create_session (session, channel, state) =
    BEGIN
        set_session_channel(session, channel);
        l_set_session_state(session, state)
    END
    ;

    set_session_state (session, state) =
    BEGIN
        l_set_session_state (session, state)
    END
    ;

    set_session_state_closed (session, is_client) =
    VAR
        l_prec_state
    IN
        reset_session_channel(session);
        // a_channel
        l_prec_state <-- get_session_state(session);
        prepare_close_session(session, l_prec_state, is_client);
        // a_user
        // a_server_token
        // a_client_token
        reset_session_to_create(session);
        // a_client_to_create
        reset_session_to_activate(session);
        // a_client_to_activate
        delete_session_application_context(session);
        // a_client_to_activate_context
        reset_session_orphaned(session);
        // a_client_orphaned
        drop_NonceClient(session);
        // a_NonceClient
        remove_NonceServer(session);
        // a_NonceServer
        remove_session(session);
        // s_session
        // a_state
        IF is_client = FALSE
        THEN
            server_session_timeout_stop_timer(session)
        END
    END
    ;

    set_session_orphaned (session, channel_config_idx) =
    VAR
        l_bool
    IN
        reset_session_channel(session);
        l_bool <-- is_t_channel_config_idx(channel_config_idx);
        IF  l_bool = TRUE THEN
            set_session_orphaned_1(session, channel_config_idx)
        END
    END

END
