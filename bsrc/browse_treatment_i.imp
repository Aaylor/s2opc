/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
   browse_treatment_i
REFINES
    browse_treatment

IMPORTS
    browse_treatment_context,
    browse_treatment_continuation_points,
    browse_treatment_result_bs,
    browse_treatment_1,
    browse_treatment_target_it,
    browse_treatment_result_it

PROMOTES
    set_session_closed,
    continuation_points_UNINITIALISATION,
    getall_browse_result_reference_at,
    getall_and_clear_browse_result,
    clear_browse_value_context,
    clear_browse_result

SEES
   constants,
   constants_statuscodes_bs,
   address_space

LOCAL_OPERATIONS

    p_maxResultRefs <-- min_nb_result_refs (p_maxTargetRef, p_nb_target) =
    PRE
        p_maxTargetRef : NAT                      &
        p_maxTargetRef <= k_n_BrowseTarget_max    &
        p_nb_target : NAT
    THEN
        IF 0 = p_maxTargetRef
        THEN
            /* No maximum of targets in results defined by clent: keep maximum number of potential targets or default max */
            IF p_nb_target < k_n_BrowseTarget_max THEN
                p_maxResultRefs := p_nb_target
            ELSE
                p_maxResultRefs := k_n_BrowseTarget_max
            END
        ELSE
            /* Limited by maximum of targets in result */
            IF  p_maxTargetRef < p_nb_target
            THEN
                p_maxResultRefs := p_maxTargetRef
            ELSE
                /* Keep the maximum number of potential targets (reduced by browse filters) */
                p_maxResultRefs := p_nb_target
            END
        END
    END
    ;

    p_serviceStatusCode, p_toContinue, p_nextIndex
      <-- fill_browse_result(p_startIndex, p_max_nb_results, p_browseView, p_src_node,
                             p_browseDirection, p_refType_defined, p_referenceType, p_includeSubtypes) =
    PRE
        p_startIndex    : NAT                       &
        p_startIndex    : t_RefIndex                &
        p_max_nb_results : NAT                      &
        p_max_nb_results <= k_n_BrowseTarget_max    &
        p_browseView : t_NodeId_i                   &
        p_src_node : t_Node_i                       &
        p_src_node : t_Node                         &
        p_browseDirection : t_BrowseDirection_i     &
        p_browseDirection : t_BrowseDirection       &
        p_refType_defined : BOOL                    &
        p_referenceType : t_NodeId_i                &
        (p_refType_defined = TRUE =>
            p_referenceType : t_NodeId)             &
        p_includeSubtypes : BOOL                    &
        isBrowseResultAllocated = TRUE              &
        max_nb_references = p_max_nb_results
    THEN
        p_serviceStatusCode,
        p_toContinue,
        p_nextIndex
        :(p_serviceStatusCode : {e_sc_ok, e_sc_bad_reference_type_id_invalid, e_sc_bad_view_id_unknown} &
          p_toContinue : BOOL &
          p_nextIndex : NAT &
          p_nextIndex : t_RefIndex &
          (p_serviceStatusCode /= e_sc_ok =>
              p_toContinue = FALSE & p_nextIndex = 0) &
          (p_serviceStatusCode = e_sc_ok & p_toContinue = TRUE =>
              p_nextIndex = p_max_nb_results)
       ) ||
        /* Use of BrowseResult iterator */
        browseResult_to_iterate,
        browseResult_iterated,
        nb_browseResult_max_refs :(
            nb_browseResult_max_refs : NAT &
            browseResult_to_iterate <: NAT &
            browseResult_iterated   <: NAT) ||
        /* Use of reference targets iterator */
        starting_node,
        references_to_iterate,
        references_iterated,
        next_reference_index :(
        starting_node : t_Node_i &
        references_to_iterate <: NAT &
        references_iterated   <: NAT &
        next_reference_index : NAT)
    END
    ;

    p_continue <-- fill_browse_result_ref(p_ref, p_browseView, p_browseDirection, p_refType_defined, p_referenceType, p_includeSubtypes) =
    PRE
        p_ref             : t_Reference_i       &
        p_ref             : t_Reference         &
        p_browseView      : t_NodeId_i          &
        p_browseDirection : t_BrowseDirection_i &
        p_browseDirection : t_BrowseDirection   &
        p_refType_defined : BOOL                &
        p_referenceType   : t_NodeId_i          &
        (p_refType_defined = TRUE =>
            p_referenceType : t_NodeId)         &
        p_includeSubtypes : BOOL                &

        browseResult_to_iterate /= {}
    THEN
        IF Is_Dir_Forward_Compatible(p_browseDirection |-> Reference_IsForward(p_ref)) = TRUE &
            (p_refType_defined = FALSE or
             p_referenceType = Reference_ReferenceType(p_ref) or
             Reference_ReferenceType(p_ref) |-> p_referenceType : Type_IsTransitiveSubtype) &
             /* Node is unknown or Node is known and NodeClass is compatible with NodeClassMask */
             (not (Reference_TargetNode(p_ref) : dom(conv_ExpandedNodeId_NodeId) &
                   conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)) : ran(a_NodeId))
              or
              (Reference_TargetNode(p_ref) : dom(conv_ExpandedNodeId_NodeId) &
               conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)) : ran(a_NodeId) &
               a_NodeClass(a_NodeId~(conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)))) : in_BrowseValue_NodeClassesInMask
              )
             )
        THEN
            /* Compatible reference, add it in a available reference index of the browse result */
            ANY l_browseResultIdx WHERE
                l_browseResultIdx : NAT &
                l_browseResultIdx : browseResult_to_iterate
            THEN
                browseResult_iterated   := browseResult_iterated   \/ {l_browseResultIdx} ||
                browseResult_to_iterate := browseResult_to_iterate -  {l_browseResultIdx} ||
                p_continue              := bool(browseResult_to_iterate /= {l_browseResultIdx}) ||
                out_BrowseResult_ReferenceTypeId (l_browseResultIdx) := Reference_ReferenceType(p_ref) ||
                out_BrowseResult_isForward (l_browseResultIdx) := Reference_IsForward(p_ref) ||
                out_BrowseResult_NodeId (l_browseResultIdx) := Reference_TargetNode(p_ref) ||
                out_BrowseResult_nb_References := l_browseResultIdx ||
                IF Reference_TargetNode(p_ref) : dom(conv_ExpandedNodeId_NodeId) &
                    conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)) : ran(a_NodeId)
                THEN
                    out_BrowseResult_BrowseName (l_browseResultIdx) := a_BrowseName(a_NodeId~(conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)))) ||
                    out_BrowseResult_DisplayName (l_browseResultIdx) := a_DisplayName(a_NodeId~(conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)))) ||
                    out_BrowseResult_NodeClass (l_browseResultIdx) := a_NodeClass(a_NodeId~(conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref)))) ||
                    out_BrowseResult_TypeDefinition (l_browseResultIdx) := Ref_HasTypeDefinition(a_NodeId~(conv_ExpandedNodeId_NodeId(Reference_TargetNode(p_ref))))
                ELSE
                    out_BrowseResult_BrowseName (l_browseResultIdx) := c_QualifiedName_indet ||
                    out_BrowseResult_DisplayName (l_browseResultIdx) := c_LocalizedText_indet ||
                    out_BrowseResult_NodeClass (l_browseResultIdx) := c_NodeClass_indet ||
                    out_BrowseResult_TypeDefinition (l_browseResultIdx) := c_ExpandedNodeId_indet
                END
            END
        ELSE
            /* if reference filtered, nothing to do and there are still browse result reference index available for next call */
            p_continue := TRUE
        END
    END

OPERATIONS

    /* LOCAL OPERATIONS */

    p_maxResultRefs <-- min_nb_result_refs (p_maxTargetRef, p_nb_target) =
    BEGIN
        IF 0 = p_maxTargetRef
        THEN
            /* No maximum of targets in results defined by clent: keep maximum number of potential targets or default max */
            IF p_nb_target < k_n_BrowseTarget_max THEN
                p_maxResultRefs := p_nb_target
            ELSE
                p_maxResultRefs := k_n_BrowseTarget_max
            END
        ELSE
            /* Limited by maximum of targets in result */
            IF  p_maxTargetRef < p_nb_target
            THEN
                p_maxResultRefs := p_maxTargetRef
            ELSE
                /* Keep the maximum number of potential targets (reduced by browse filters) */
                p_maxResultRefs := p_nb_target
            END
        END
    END
    ;

    /* When the target node fulfills all the filtering conditions, then fill its data and iterate
       on the browse result index.
       p_ref             : reference to evaluate
       p_browseDirection : direction(s) of references to filter
       p_refType_defined : indicates whether the reference type should be filtered. The following 2
                           parameters are meaningfull only when this one is true
       p_referenceType   : reference type to filter
       p_includeSubtypes : indicates whether subtypes should be filtered. Else only the given reference
                           type is filtered
       p_continue        : indicates whether the iteration should continue (it should stop if the
                           maximum number of browse response index has just been filled)
    */
    p_continue <-- fill_browse_result_ref(p_ref, p_browseView, p_browseDirection,
                                          p_refType_defined, p_referenceType, p_includeSubtypes) =
    VAR
        l_RefType,
        l_TargetNode,
        l_IsForward,
        l_res,
        l_bri,
        l_BrowseName,
        l_DisplayName,
        l_NodeClass,
        l_TypeDefinition,
        l_NodeClassInMask
    IN
        p_continue := TRUE;
        unused_browse_view (p_browseView); // TODO: filtering using browse view
        l_RefType    <-- get_Reference_ReferenceType(p_ref);
        l_TargetNode <-- get_Reference_TargetNode(p_ref);
        l_IsForward  <-- get_Reference_IsForward(p_ref);
        l_res        <-- get_Is_Dir_Forward_Compatible(p_browseDirection, l_IsForward);
        IF  l_res = TRUE THEN
            l_res <-- Is_RefTypes_Compatible(p_refType_defined, p_referenceType, p_includeSubtypes, l_RefType);
            IF  l_res = TRUE THEN
                l_BrowseName, l_DisplayName, l_NodeClass, l_TypeDefinition <-- get_optional_fields_ReferenceDescription(l_TargetNode);
                l_NodeClassInMask <-- is_NodeClass_in_NodeClassMask (l_NodeClass);
                IF l_NodeClassInMask = TRUE THEN
                    p_continue, l_bri <-- continue_iter_browseResult;
                    setall_browse_result_reference_at (l_bri, l_RefType, l_IsForward, l_TargetNode,
                                                       l_BrowseName, l_DisplayName, l_NodeClass, l_TypeDefinition)
                END
            END
        END
    END
    ;

    /* Fills the browse result on one given source node.
       Iterates on each reference (starting from p_startIndex) of the source node:
       p_startIndex     : reference index used to start iteration on source node references (to be able to continue)
       p_max_nb_results : maximum number of results (number of references on the source node before filtering)
       p_browseView     : browse view node Id (unused for filtering for now)
       p_src_node       : source node from which refences should start
       p_browseDirection: direction(s) of references to filter
       p_refType_defined: indicates whether the reference type should be filtered. The following 2
                          parameters are meaningfull only when this one is true
       p_referenceType  : reference type to filter
       p_includeSubtypes: indicates whether subtypes should be filtered. Else only the given reference
                          type is filtered
    */
    p_serviceStatusCode, p_toContinue, p_nextIndex <-- fill_browse_result(p_startIndex, p_max_nb_results, p_browseView,
                                                                          p_src_node, p_browseDirection, p_refType_defined,
                                                                          p_referenceType, p_includeSubtypes) =
    VAR
        l_continue_bri,
        l_continue_ref,
        l_ref
    IN
        p_serviceStatusCode := e_sc_ok; /* TODO: check if the reference type is valid ?
                                           Silently fail if we do not know the reference type during typecheck for now (no result will be found) */
        l_ref := c_Reference_indet;
        /* Initialization of the iteration on the browse result */
        l_continue_bri <-- init_iter_browseResult(p_max_nb_results);
        /* Loop on the references starting on the source node */
        l_continue_ref <-- init_iter_reference(p_src_node, p_startIndex);
        p_nextIndex := p_startIndex;
        WHILE
            l_continue_ref = TRUE &
            l_continue_bri = TRUE
        DO
            l_continue_ref, l_ref, p_nextIndex <-- continue_iter_reference;
            /* When the target node fulfills all the filtering conditions, then
            fill its data and iterate on the browse result index */
            l_continue_bri <-- fill_browse_result_ref(l_ref, p_browseView, p_browseDirection, p_refType_defined,
                                                      p_referenceType, p_includeSubtypes)
        INVARIANT
            /* Iteration on references from source node */
            references_to_iterate <: NAT &
            references_iterated   <: NAT &
            references_to_iterate /\ references_iterated = {} &
            next_reference_index : NAT &
            card(references_to_iterate) = Node_RefIndexEnd(p_src_node) - p_startIndex + 1 &

            /* Iteration on browse result stored references */
            browseResult_to_iterate <: NAT &
            browseResult_iterated   <: NAT &
            browseResult_to_iterate /\ browseResult_iterated = {} &
            nb_browseResult_max_refs = card(browseResult_to_iterate \/ browseResult_iterated) &

            /* Mandatory defined part of browse result for iterated indexes */
            out_BrowseResult_ReferenceTypeId : browseResult_iterated --> t_NodeId &
            out_BrowseResult_isForward : browseResult_iterated --> BOOL &
            out_BrowseResult_NodeId : browseResult_iterated --> t_ExpandedNodeId &
            /* Optional defined part of browse result for iterated indexes (external target node or degraded case if target node not found) */
            out_BrowseResult_BrowseName : browseResult_iterated --> t_QualifiedName_i &
            out_BrowseResult_DisplayName : browseResult_iterated --> t_LocalizedText_i &
            out_BrowseResult_NodeClass : browseResult_iterated --> t_NodeClass_i &
            out_BrowseResult_TypeDefinition : browseResult_iterated --> t_ExpandedNodeId_i &

            out_BrowseResult_nb_References = card(browseResult_iterated)
        VARIANT
            card(references_to_iterate)
        END;
        /* There are references remaining but no more free indexes available in BrowseResult => continuatoin point needed */
        p_toContinue := bool(l_continue_ref = TRUE & l_continue_bri = FALSE)

    END
    ;

    /* END OF LOCAL OPERATIONS */

   set_browse_value_context (p_session, p_maxTargetRef, p_browseView, p_nodeId,
                             p_browseDirection, p_referenceType, p_includeSubtypes, p_nodeClassMask) =
   BEGIN
       /* Only set context to start with index 1 of target references */
       setall_browse_value_context(1, p_session, p_maxTargetRef, p_browseView, p_nodeId,
                                   p_browseDirection, p_referenceType, p_includeSubtypes, p_nodeClassMask)
   END
   ;

   p_service_StatusCode <-- set_browse_value_context_from_continuation_point (p_session, p_continuationPoint) =
   VAR
       l_res,
       l_nextIndex,
       l_maxTargetRef,
       l_browseView,
       l_nodeId,
       l_browseDirection,
       l_referenceType,
       l_includeSubtypes,
       l_nodeClassMask
   IN
        p_service_StatusCode := e_sc_bad_continuation_point_invalid;
        l_res,
        l_nextIndex,
        l_maxTargetRef,
        l_browseView,
        l_nodeId,
        l_browseDirection,
        l_referenceType,
        l_includeSubtypes,
        l_nodeClassMask<-- getall_and_clear_continuation_point (p_session, p_continuationPoint);
        IF l_res = TRUE THEN
            setall_browse_value_context(l_nextIndex, p_session, l_maxTargetRef, l_browseView,
                                        l_nodeId, l_browseDirection, l_referenceType, l_includeSubtypes, l_nodeClassMask);
            p_service_StatusCode := e_sc_ok
        END
   END
   ;

   p_serviceStatusCode, p_continuationPoint, p_nbReferences <-- compute_browse_result =
   VAR
       l_startIndex,
       l_session,
       l_maxTargetRef,
       l_browseView,
       l_nodeId,
       l_browseDirection,
       l_refType_defined,
       l_referenceType,
       l_includeSubtypes,
       l_nodeClassMask,
       l_is_src_node_valid,
       l_nb_target,
       l_src_node,
       l_alloc_bres,
       l_max_nb_results,
       l_toContinue,
       l_nextIndex,
       l_cp_bres
   IN
       p_continuationPoint := c_ContinuationPoint_indet;
       p_nbReferences := 0;
        /* Get input context */
        l_startIndex, l_session, l_maxTargetRef, l_browseView, l_nodeId,
          l_browseDirection, l_refType_defined, l_referenceType, l_includeSubtypes, l_nodeClassMask <-- getall_browse_value_context;
        /* Retrieve source node in address space */
        l_is_src_node_valid, l_nb_target, l_src_node <-- getall_SourceNode_NbRef(l_nodeId);
        IF  l_is_src_node_valid = TRUE THEN
            /* Keep the minimum between the maximum of targets allowed in result and the maximum number of potential targets */
            l_max_nb_results <-- min_nb_result_refs (l_maxTargetRef, l_nb_target);
            /* Allocate a BrowseResult with maximum number of references (reached if none reference is filtered)*/
            l_alloc_bres <-- alloc_browse_result(l_max_nb_results);
            IF  l_alloc_bres = TRUE THEN
                p_serviceStatusCode, l_toContinue, l_nextIndex
                  <-- fill_browse_result (l_startIndex, l_max_nb_results, l_browseView, l_src_node,
                                          l_browseDirection, l_refType_defined, l_referenceType, l_includeSubtypes);
                IF l_toContinue = TRUE THEN
                    l_cp_bres, p_continuationPoint <-- create_continuation_point (l_session, l_nextIndex, l_maxTargetRef, l_browseView,
                                                                                  l_nodeId, l_browseDirection, l_referenceType, l_includeSubtypes, l_nodeClassMask);
                    IF l_cp_bres = FALSE THEN
                        p_serviceStatusCode := e_sc_bad_no_continuation_points
                    END
                END
            ELSE
                p_serviceStatusCode := e_sc_bad_out_of_memory
            END
        ELSE
            p_serviceStatusCode := e_sc_bad_node_id_unknown
        END
    END

END
