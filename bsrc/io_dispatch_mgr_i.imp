/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION io_dispatch_mgr_i
REFINES io_dispatch_mgr

SEES
    constants

IMPORTS
    service_mgr,
    channel_mgr

LOCAL_OPERATIONS

    header_type <-- get_msg_header_type (msg_typ) =
    PRE
        msg_typ : t_msg_type_i &
        msg_typ : t_msg_type
    THEN
        IF msg_typ : s_service_reqs
        THEN
            header_type := e_msg_request_type
        ELSIF msg_typ : s_service_resps
        THEN
            header_type := e_msg_response_type
        ELSE
            header_type := c_msg_header_type_indet
        END
    END
    ;

    service_class <-- get_msg_service_class (msg_typ) =
    PRE
        msg_typ : t_msg_type_i &
        msg_typ : t_msg_type
    THEN
        IF msg_typ : s_discovery_service_reqs \/ s_discovery_service_resps
        THEN
            service_class := e_msg_discovery_service_class
        ELSIF msg_typ : s_service_on_session_reqs \/ s_service_on_session_resps
        THEN
            service_class := e_msg_session_service_class
        ELSIF msg_typ : s_session_treatment_reqs \/ s_session_treatment_resps
        THEN
            service_class := e_msg_session_treatment_class
        ELSIF msg_typ = e_msg_service_fault_resp
        THEN
            service_class := e_msg_service_fault_class
        ELSE
            service_class := c_msg_service_class_indet
        END
    END

OPERATIONS

    header_type <-- get_msg_header_type (msg_typ) =
    BEGIN
        header_type := c_msg_header_type_indet;
        CASE msg_typ OF
            EITHER e_msg_session_create_req,
                e_msg_session_activate_req,
                e_msg_session_close_req,
                e_msg_session_cancel_req,
                e_msg_node_add_nodes_req,
                e_msg_node_add_references_req,
                e_msg_node_delete_nodes_req,
                e_msg_node_delete_references_req,
                e_msg_view_browse_req,
                e_msg_view_browse_next_req,
                e_msg_view_translate_browse_paths_to_node_ids_req,
                e_msg_view_register_nodes_req,
                e_msg_view_unregister_nodes_req,
                e_msg_query_first_req,
                e_msg_query_next_req,
                e_msg_attribute_read_req,
                e_msg_attribute_history_read_req,
                e_msg_attribute_write_req,
                e_msg_attribute_history_update_req,
                e_msg_method_call_req,
                e_msg_monitored_items_create_req,
                e_msg_monitored_items_modify_req,
                e_msg_monitored_items_set_monitoring_mode_req,
                e_msg_monitored_items_set_triggering_req,
                e_msg_monitored_items_delete_req,
                e_msg_subscription_create_req,
                e_msg_subscription_modify_req,
                e_msg_subscription_set_publishing_mode_req,
                e_msg_subscription_publish_req,
                e_msg_subscription_republish_req,
                e_msg_subscription_transfer_subscriptions_req,
                e_msg_subscription_delete_subscriptions_req,
                e_msg_discovery_find_servers_req,
                e_msg_discovery_find_servers_on_network_req,
                e_msg_discovery_get_endpoints_req,
                e_msg_discovery_register_server_req,
                e_msg_discovery_register_server2_req
            THEN
                header_type := e_msg_request_type
            OR e_msg_session_create_resp,
                e_msg_session_activate_resp,
                e_msg_session_close_resp,
                e_msg_session_cancel_resp,
                e_msg_node_add_nodes_resp,
                e_msg_node_add_references_resp,
                e_msg_node_delete_nodes_resp,
                e_msg_node_delete_references_resp,
                e_msg_view_browse_resp,
                e_msg_view_browse_next_resp,
                e_msg_view_translate_browse_paths_to_node_ids_resp,
                e_msg_view_register_nodes_resp,
                e_msg_view_unregister_nodes_resp,
                e_msg_query_first_resp,
                e_msg_query_next_resp,
                e_msg_attribute_read_resp,
                e_msg_attribute_history_read_resp,
                e_msg_attribute_write_resp,
                e_msg_attribute_history_update_resp,
                e_msg_method_call_resp,
                e_msg_monitored_items_create_resp,
                e_msg_monitored_items_modify_resp,
                e_msg_monitored_items_set_monitoring_mode_resp,
                e_msg_monitored_items_set_triggering_resp,
                e_msg_monitored_items_delete_resp,
                e_msg_subscription_create_resp,
                e_msg_subscription_modify_resp,
                e_msg_subscription_set_publishing_mode_resp,
                e_msg_subscription_publish_resp,
                e_msg_subscription_republish_resp,
                e_msg_subscription_transfer_subscriptions_resp,
                e_msg_subscription_delete_subscriptions_resp,
                e_msg_discovery_find_servers_resp,
                e_msg_discovery_find_servers_on_network_resp,
                e_msg_discovery_get_endpoints_resp,
                e_msg_discovery_register_server_resp,
                e_msg_discovery_register_server2_resp,
                /* generic service fault */
                e_msg_service_fault_resp
            THEN
                header_type := e_msg_response_type
            END
        END
    END
    ;

    service_class <-- get_msg_service_class (msg_typ) =
    BEGIN
        CASE msg_typ OF
            EITHER e_msg_discovery_find_servers_req,
                e_msg_discovery_find_servers_resp,
                e_msg_discovery_find_servers_on_network_req,
                e_msg_discovery_find_servers_on_network_resp,
                e_msg_discovery_get_endpoints_req,
                e_msg_discovery_get_endpoints_resp,
                e_msg_discovery_register_server_req,
                e_msg_discovery_register_server_resp,
                e_msg_discovery_register_server2_req,
                e_msg_discovery_register_server2_resp
            THEN
                service_class := e_msg_discovery_service_class
            OR e_msg_session_create_req,
                e_msg_session_create_resp,
                e_msg_session_activate_req,
                e_msg_session_activate_resp,
                e_msg_session_close_req,
                e_msg_session_close_resp,
                e_msg_session_cancel_req,
                e_msg_session_cancel_resp
            THEN
                service_class := e_msg_session_treatment_class
            OR e_msg_node_add_nodes_req,
                e_msg_node_add_nodes_resp,
                e_msg_node_add_references_req,
                e_msg_node_add_references_resp,
                e_msg_node_delete_nodes_req,
                e_msg_node_delete_nodes_resp,
                e_msg_node_delete_references_req,
                e_msg_node_delete_references_resp,
                e_msg_view_browse_req,
                e_msg_view_browse_resp,
                e_msg_view_browse_next_req,
                e_msg_view_browse_next_resp,
                e_msg_view_translate_browse_paths_to_node_ids_req,
                e_msg_view_translate_browse_paths_to_node_ids_resp,
                e_msg_view_register_nodes_req,
                e_msg_view_register_nodes_resp,
                e_msg_view_unregister_nodes_req,
                e_msg_view_unregister_nodes_resp,
                e_msg_query_first_req,
                e_msg_query_first_resp,
                e_msg_query_next_req,
                e_msg_query_next_resp,
                e_msg_attribute_read_req,
                e_msg_attribute_read_resp,
                e_msg_attribute_history_read_req,
                e_msg_attribute_history_read_resp,
                e_msg_attribute_write_req,
                e_msg_attribute_write_resp,
                e_msg_attribute_history_update_req,
                e_msg_attribute_history_update_resp,
                e_msg_method_call_req,
                e_msg_method_call_resp,
                e_msg_monitored_items_create_req,
                e_msg_monitored_items_create_resp,
                e_msg_monitored_items_modify_req,
                e_msg_monitored_items_modify_resp,
                e_msg_monitored_items_set_monitoring_mode_req,
                e_msg_monitored_items_set_monitoring_mode_resp,
                e_msg_monitored_items_set_triggering_req,
                e_msg_monitored_items_set_triggering_resp,
                e_msg_monitored_items_delete_req,
                e_msg_monitored_items_delete_resp,
                e_msg_subscription_create_req,
                e_msg_subscription_create_resp,
                e_msg_subscription_modify_req,
                e_msg_subscription_modify_resp,
                e_msg_subscription_set_publishing_mode_req,
                e_msg_subscription_set_publishing_mode_resp,
                e_msg_subscription_publish_req,
                e_msg_subscription_publish_resp,
                e_msg_subscription_republish_req,
                e_msg_subscription_republish_resp,
                e_msg_subscription_transfer_subscriptions_req,
                e_msg_subscription_transfer_subscriptions_resp,
                e_msg_subscription_delete_subscriptions_req,
                e_msg_subscription_delete_subscriptions_resp
            THEN
                service_class := e_msg_session_service_class
            OR e_msg_service_fault_resp
            THEN
                service_class := e_msg_service_fault_class
            ELSE
                service_class := c_msg_service_class_indet
            END
        END
    END
    ;

    /* END OF LOCAL OPERATIONS */

    receive_msg_buffer (channel, buffer, request_context) =
    VAR
        l_connected_channel,
        l_is_client,
        l_msg_type,
        l_valid_msg_type,
        l_msg_header_type,
        l_msg_service_class,
        l_buffer_out,
        l_valid_buffer_out,
        l_valid_req_context
    IN
        l_connected_channel <-- is_connected_channel (channel);
        l_msg_type <-- decode_msg_type (buffer);
        l_valid_msg_type <-- is_valid_msg_in_type (l_msg_type);
        IF l_connected_channel = TRUE &
            l_valid_msg_type = TRUE
        THEN
            l_is_client <-- is_client_channel (channel);
            l_msg_header_type <-- get_msg_header_type (l_msg_type);
            l_msg_service_class <-- get_msg_service_class (l_msg_type);
            /* TODO: check that channel is secured if service class /= discovery class */
            CASE l_msg_header_type OF
                EITHER e_msg_request_type THEN
                    l_valid_req_context <-- is_valid_request_context (request_context);
                    IF l_is_client = FALSE &
                        l_valid_req_context = TRUE
                    THEN
                        /* Server receiving a request: OK */
                        CASE l_msg_service_class OF
                            EITHER e_msg_session_treatment_class THEN
                                l_buffer_out <-- server_receive_session_treatment_req (channel, l_msg_type, buffer)
                            OR e_msg_session_service_class THEN
                                l_buffer_out <-- server_receive_session_service_req (channel, l_msg_type, buffer)
                            OR e_msg_discovery_service_class THEN
                                l_buffer_out <-- server_receive_discovery_service_req (channel, l_msg_type, buffer)
                            ELSE /* INCLUDES e_msg_service_fault_class => unexpected response type */
                                /* indet class */
                                l_buffer_out := c_byte_buffer_indet
                            END
                        END;
                        /* Send the response message on secure channel if available */
                        l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
                        IF l_valid_buffer_out = TRUE
                        THEN
                            send_channel_msg_buffer (channel, l_buffer_out, request_context)
                        END
                    ELSE
                        /* Server receiving a response: close secure channel since it is not expected from client */
                        close_secure_channel (channel)
                    END
                OR e_msg_response_type THEN
                    IF l_is_client = TRUE
                    THEN
                        /* Client receiving a response: OK */
                        CASE l_msg_service_class OF
                            EITHER e_msg_session_treatment_class THEN
                                client_receive_session_treatment_resp (channel, l_msg_type, buffer)
                            OR e_msg_session_service_class THEN
                                client_receive_session_service_resp (channel, l_msg_type, buffer)
                            OR e_msg_discovery_service_class THEN
                                /* TODO: check channel <-> req handle corresp ?: for now req handle unique in client */
                                client_receive_discovery_service_resp (l_msg_type, buffer)
                            OR e_msg_service_fault_class THEN
                                /* TODO: manage cas in which we do not know the service type ! */                                
                                skip
                            END
                        END
                    ELSE
                        /* Client receiving a request: close secure channel since it is not expected from server */
                        close_secure_channel (channel)
                    END
                ELSE
                    /* TODO: generic management of unknown message type */
                    skip
                END
            END
        END
    END
    ;

    client_channel_connected_event (channel_config_idx, channel) =
    VAR
        l_bres
    IN
        l_bres <-- cli_set_connected_channel (channel_config_idx, channel);
        IF l_bres = TRUE
        THEN
            client_channel_connected_event_session (channel_config_idx, channel)
        END
    END
    ;

    client_secure_channel_timeout (channel_config_idx) =
    VAR
        l_bres
    IN
        l_bres <-- cli_set_connection_timeout_channel (channel_config_idx)
    END
    ;

    server_channel_connected_event (endpoint_config_idx, channel_config_idx, channel) =
    VAR
        l_bres
    IN
        l_bres <-- srv_new_secure_channel (endpoint_config_idx, channel_config_idx, channel)
    END
    ;

    bres <-- client_activate_new_session (channel_config_idx, user) =
    VAR
        l_channel,
        l_connected_channel
    IN
        bres := FALSE;
        l_channel <-- get_connected_channel (channel_config_idx);
        l_connected_channel <-- is_connected_channel (l_channel);
        IF l_connected_channel = FALSE
        THEN
            bres <-- cli_open_secure_channel (channel_config_idx);
            IF bres = TRUE
            THEN
                /* No connected channel: will trigger create session and then activate session events asynchronously */
                bres <-- client_async_activate_new_session_without_channel (channel_config_idx, user)
            END
        ELSE
            /* Already connected channel: will trigger a create session event synchronously
               and then activate session event asynchronously */
            bres <-- client_async_activate_new_session_with_channel (channel_config_idx, l_channel, user)
        END
    END
    ;

    ret <-- client_reactivate_session_new_user (session, user) =
    VAR
        l_channel,
        l_connected_channel,
        l_buffer_out,
        l_valid_buffer_out
    IN
        ret, l_channel, l_buffer_out <-- client_service_activate_session (session, user);
        IF ret = e_sc_ok
        THEN
            l_connected_channel <-- is_connected_channel (l_channel);
            l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
            IF l_connected_channel = TRUE &
                l_valid_buffer_out = TRUE
            THEN
                send_channel_msg_buffer (l_channel, l_buffer_out, c_request_context_indet)
            END
        END
    END
    ;

    ret <-- client_send_service_request (session, req_msg) =
    VAR
        l_channel,
        l_connected_channel,
        l_buffer_out,
        l_valid_buffer_out
    IN
        ret, l_channel, l_buffer_out <-- client_service_request (session, req_msg);
        IF ret = e_sc_ok
        THEN
            l_connected_channel <-- is_connected_channel (l_channel);
            l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
            IF l_connected_channel = TRUE &
                l_valid_buffer_out = TRUE
            THEN
                send_channel_msg_buffer (l_channel, l_buffer_out, c_request_context_indet)
            END
        END
    END
    ;

    ret <-- client_send_close_session_request (session) =
    VAR
        l_channel,
        l_connected_channel,
        l_buffer_out,
        l_valid_buffer_out
    IN
        ret, l_channel, l_buffer_out <-- client_service_close_session (session);
        IF ret = e_sc_ok
        THEN
            l_connected_channel <-- is_connected_channel (l_channel);
            l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
            IF l_connected_channel = TRUE &
                l_valid_buffer_out = TRUE
            THEN
                send_channel_msg_buffer (l_channel, l_buffer_out, c_request_context_indet)
            END
        END
    END
    ;

    internal_client_create_session (session, channel_config_idx) =
    VAR
        l_channel,
        l_connected_channel,
        l_buffer_out,
        l_valid_buffer_out,
        l_ret
    IN
        l_channel <-- get_connected_channel (channel_config_idx);
        l_connected_channel <-- is_connected_channel (l_channel);
        IF l_connected_channel = FALSE
        THEN
            /* In case internal event to create session cannot be done => close session */
            client_close_session (session)
        ELSE
            l_buffer_out <-- client_service_create_session (session, l_channel);
            /* Send the response message on secure channel if available */
            l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
            IF l_valid_buffer_out = TRUE
            THEN
                send_channel_msg_buffer (l_channel, l_buffer_out, c_request_context_indet)
            END
        END
    END
    ;

    internal_client_activate_orphaned_session (session, channel_config_idx) =
    VAR
        l_channel,
        l_connected_channel,
        l_buffer_out,
        l_valid_buffer_out
    IN
        l_channel <-- get_connected_channel (channel_config_idx);
        l_connected_channel <-- is_connected_channel (l_channel);
        IF l_connected_channel = FALSE
        THEN
            l_buffer_out <-- client_service_activate_orphaned_session (session, l_channel);
            l_valid_buffer_out <-- is_valid_buffer_out (l_buffer_out);
            IF l_valid_buffer_out = TRUE
            THEN
                send_channel_msg_buffer (l_channel, l_buffer_out, c_request_context_indet)
            END
        END
    END
    ;

    secure_channel_lost (channel) =
    VAR
        l_connected_channel,
        l_disconnecting_channel,
        l_valid_new_channel,
        l_is_client,
        l_channel_config_idx,
        l_new_channel,
        l_bres
    IN
        l_connected_channel <-- is_connected_channel (channel);
        IF l_connected_channel = TRUE
        THEN
            l_is_client <-- is_client_channel (channel);
            IF l_is_client = TRUE
            THEN
                l_channel_config_idx <-- get_channel_info (channel);
                l_disconnecting_channel <-- is_disconnecting_channel (l_channel_config_idx);
                client_secure_channel_lost_session_sm (channel, l_channel_config_idx);
                IF l_disconnecting_channel = FALSE
                THEN
                    // attempt to reconnect channel
                    l_new_channel <-- get_connected_channel (l_channel_config_idx);
                    IF l_new_channel = c_channel_indet
                    THEN
                        l_bres <-- cli_open_secure_channel (l_channel_config_idx)
                        // async operation => cannot use channel until connection is effective ?
                    END;

                    l_valid_new_channel <-- is_connected_channel (l_new_channel);

                    IF l_valid_new_channel = TRUE
                    THEN
                        client_channel_connected_event_session (l_channel_config_idx, l_new_channel)
                    END
                END
            ELSE
                server_secure_channel_lost_session_sm (channel)
            END;
            channel_lost (channel)
        END
    END
    ;

    bres <-- close_all_active_connections =
    BEGIN
        bres <-- close_all_channel
    END

END
