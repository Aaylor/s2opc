/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    session_core_i
REFINES
    session_core

SEES
    constants,
    message_in_bs,
    message_out_bs,
    channel_mgr_bs,
    request_handle_bs

IMPORTS
    session_core_1_bs,
    session_core_orphaned_it_bs,
    session_core_channel_lost_it_bs

PROMOTES
    init_iter_orphaned_t_session,
    continue_iter_orphaned_t_session,

    server_get_session_from_token,
    client_get_token_from_session,
    get_session_channel,
    is_valid_session,
    is_valid_user,
    delete_session

LOCAL_OPERATIONS

    res_activated <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg) =
    PRE
        channel       : t_channel_i &
        channel       : s_channel_connected &
        session       : t_session_i &
        session       : s_session &
        user          : t_user_i &
        user          : t_user &
        a_state(session) : {e_session_created, e_session_userActivated, e_session_scOrphaned} &
        activate_req_msg : t_msg_i &
        activate_req_msg = c_msg_in &
        c_msg_in : t_msg &
        a_msg_in_type = e_msg_session_activate_req &
        activate_resp_msg : t_msg_i &
        activate_resp_msg = c_msg_out &
        c_msg_out : t_msg &
        a_msg_out_type = e_msg_session_activate_resp
    THEN
        CHOICE
            a_state(session) := e_session_userActivated ||
            a_channel(session) := channel ||
            a_user(session) := user ||
            res_activated := TRUE
        OR
            res_activated := FALSE
        END
    END

OPERATIONS

    res_activated <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg) =
    VAR
        l_channel_config_idx,
        l_secpol,
        l_nonce
    IN
        l_channel_config_idx <-- get_channel_info (channel);
        l_secpol <-- get_SecurityPolicy(channel);
        IF l_secpol /= e_secpol_None THEN
            res_activated <-- server_activate_session_check_crypto(session, channel, l_channel_config_idx, activate_req_msg);
            IF res_activated = TRUE THEN
                l_nonce <-- get_NonceServer(session);
                write_activate_session_resp_msg_crypto(activate_resp_msg, l_nonce)
            END
        ELSE
            res_activated := TRUE
        END;
        IF res_activated = TRUE THEN
            set_session_user (session, user);
            set_session_channel (session, channel);
            set_session_state (session, e_session_userActivated)
        END
    END
    ;

    /* END OF LOCAL OPERATIONS */
    nsession <-- client_init_session_sm =
    BEGIN
        nsession <-- init_new_session (TRUE)
    END;

    valid <-- client_create_session_req_sm (session, channel, create_req_msg) =
    VAR
        l_channel_config_idx,
        l_nonce_needed,
        l_nonce_valid,
        l_nonce
    IN
        create_session (session, channel, e_session_creating);
        l_channel_config_idx <-- get_channel_info (channel);
        valid, l_nonce_needed <-- client_create_session_req_do_crypto(session, channel, l_channel_config_idx);
        IF valid = TRUE THEN
            write_create_session_req_msg_endpointUrl (create_req_msg, l_channel_config_idx);
            IF l_nonce_needed = TRUE THEN
                l_nonce <-- get_NonceClient(session);
                write_create_session_req_msg_crypto(create_req_msg, l_channel_config_idx, l_nonce)
            END
            /* TODO: Fill remaining parameters: sessionName, timeout, maxResponseSize */
            /*write_create_session_req_msg_fill(create_req_msg, l_channel_config_idx) */
        END
    END
    ;

    nsession, service_ret <-- server_create_session_req_and_resp_sm (channel, create_req_msg, create_resp_msg) =
    VAR
        l_nsession,
        l_valid_session,
        l_nsession_token,
        l_valid_session_token,
        l_endpoint_config_idx,
        /*l_valid_req,*/
        l_config_idx,
        l_valid_crypto,
        l_signature,
        l_nonce,
        l_secpol
    IN
        l_nsession <-- init_new_session (FALSE);
        l_valid_session <-- is_valid_session (l_nsession);
        IF l_valid_session = TRUE THEN
            create_session(l_nsession, channel, e_session_created);
            /* TODO: check request parameters: client certificate, endpointURL*/
            /*l_valid_req <-- server_create_session_valid_req(create_req_msg) */
            l_nsession_token <-- server_get_fresh_session_token (l_nsession);
            l_valid_session_token <-- server_is_valid_session_token (l_nsession_token);
            IF l_valid_session_token = TRUE /*& l_valid_req = TRUE */
            THEN
                l_endpoint_config_idx <-- server_get_endpoint_config (channel);
                /* No need to store the handle since we will send response in same step */
                write_create_session_msg_session_token (create_resp_msg, l_nsession_token);
                /* TODO: this one also populates RevisedSessionTimeout */
                service_ret <-- write_create_session_msg_server_endpoints (create_req_msg, create_resp_msg, l_endpoint_config_idx);
                /* TODO: populate msg with remaining parameters: MaxRequestSize, RevisedSessionTimeout, CertServer, ... */
                IF service_ret = e_sc_ok THEN
                    l_secpol <-- get_SecurityPolicy(channel);
                    IF l_secpol /= e_secpol_None THEN
                        /* Do the cryptographic challenge which may fail because of mallocs */
                        l_config_idx <-- get_channel_info(channel); /* MAYBE this is denoted client side only... */
                        l_valid_crypto, l_signature <-- server_create_session_req_do_crypto(l_nsession, create_req_msg, l_endpoint_config_idx, l_config_idx);
                        IF  l_valid_crypto = TRUE THEN
                            l_nonce <-- get_NonceServer(l_nsession);
                            service_ret <-- write_create_session_resp_msg_crypto(create_resp_msg, l_config_idx, l_nonce, l_signature)
                        ELSE
                            /* TODO: add bad security check failed error and use it instead */
                            service_ret := e_sc_bad_unexpected_error
                        END
                    END
                END
            ELSE
                service_ret := e_sc_bad_out_of_memory;
                delete_session (l_nsession);
                l_nsession := c_session_indet
            END
        ELSE
            service_ret := e_sc_bad_out_of_memory
        END;
        nsession := l_nsession
    END
    ;

    ret <-- client_create_session_resp_sm (channel, session, session_token, create_resp_msg) =
    VAR
        l_nonce,
        l_valid,
        l_channel_config_idx,
        l_secpol
    IN
        /* TODO: check Request:handle == Response:handle ; Response:Cert_server == Cert_server */
        /* TODO? check Response:serverEndpoints */
        /* Check server signature */
        ret := e_sc_ok;
        l_secpol <-- get_SecurityPolicy(channel);
        IF l_secpol /= e_secpol_None THEN
            /* Note: receiving a request implies that we sent it, and Nonce, if needed, was valid, hence get_NonceClient cannot fail. */
            /* TODO: at least validate nonce value. In this case it could also be better to have it as parameter of check_crypto ! */
            l_nonce <-- get_NonceClient(session);
            l_channel_config_idx <-- get_channel_info (channel);
            l_valid <-- client_create_session_check_crypto(session, l_channel_config_idx, create_resp_msg);
            IF l_valid = TRUE THEN
                // channel: only for the precondition
                set_session_state (session, e_session_created);
                client_set_session_token (session, session_token);
                drop_NonceClient(session)
            ELSE
                ret := e_sc_nok
            END
        ELSE
            set_session_state (session, e_session_created);
            client_set_session_token (session, session_token)
        END
    END
    ;

    ret, channel, session_token <-- client_user_activate_session_req_sm (session, user, activate_req_msg) =
    VAR
        l_is_connected_channel,
        l_channel_config_idx,
        l_secpol,
        l_valid_crypto,
        l_signature,
        l_server_nonce
    IN
        channel <-- get_session_channel (session);
        l_is_connected_channel <-- is_connected_channel(channel);
        IF l_is_connected_channel = TRUE THEN
            session_token <-- client_get_token_from_session (session);
            l_channel_config_idx <-- get_channel_info (channel);
            /* TODO: check validity of user */
            /* TODO: populate msg with parameters */
            write_activate_msg_user(activate_req_msg, user);
            l_secpol <-- get_SecurityPolicy(channel);
            IF l_secpol /= e_secpol_None THEN
                l_server_nonce <-- get_NonceServer(session);
                // TODO: validate server nonce ? Or guaranteed by session state ?
                l_valid_crypto, l_signature <-- client_activate_session_req_do_crypto(session, l_channel_config_idx, l_server_nonce);
                IF l_valid_crypto = TRUE THEN
                    ret <-- write_activate_session_req_msg_crypto(activate_req_msg, l_signature)
                ELSE
                    /* TODO: add bad security check failed error and use it instead */
                    ret := e_sc_bad_unexpected_error
                END
            ELSE
                ret := e_sc_ok
            END
        ELSE
            channel := c_channel_indet;
            session_token := c_session_token_indet;
            ret := e_sc_bad_unexpected_error
        END;
        IF ret = e_sc_ok THEN
            set_session_user(session, user);
            set_session_state(session, e_session_userActivating)
        END
    END
    ;

    session_token <-- client_sc_activate_session_req_sm (session, channel, activate_req_msg) =
    VAR
        l_user
    IN
        session_token <-- client_get_token_from_session (session);
        l_user <-- get_session_user (session);
        /* TODO: populate msg with parameters  */
        write_activate_msg_user(activate_req_msg, l_user);
        set_session_channel(session, channel);
        set_session_state(session, e_session_scActivating)
    END
    ;

    ret <-- server_activate_session_req_and_resp_sm (channel, session, user, activate_req_msg, activate_resp_msg) =
    VAR
        l_channel,
        l_user,
        l_state,
        l_valid,
        l_ret
    IN
        l_channel <-- get_session_channel (session);
        l_user <-- get_session_user (session);
        l_state <-- get_session_state (session);
        IF l_state = e_session_created
        THEN
            /* Channel must be the same and user must be set */
            IF l_channel = channel
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* TODO: return detailed error from transition */
                    l_ret := e_sc_bad_unexpected_error
                END
            ELSE
                l_ret := e_sc_bad_invalid_argument
            END
        ELSIF l_state = e_session_userActivated
        THEN
            /* User changed XOR channel changed */
            IF l_channel = channel &
                l_user /= user
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* TODO: return detailed error from transition */
                    l_ret := e_sc_bad_unexpected_error
                END
            ELSIF l_channel /= channel &
                l_user = user
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* TODO: return detailed error from transition */
                    l_ret := e_sc_bad_unexpected_error
                END
            ELSE
                l_ret := e_sc_bad_invalid_argument
            END
        ELSIF l_state = e_session_scOrphaned
        THEN
            /* Channel changed */
            IF l_channel /= channel &
                l_user = user
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel, session, user, activate_req_msg, activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* TODO: return detailed error from transition */
                    l_ret := e_sc_bad_unexpected_error
                END
            ELSE
                l_ret := e_sc_bad_invalid_argument
            END
        ELSE
            l_ret := e_sc_bad_invalid_state
        END;
        ret := l_ret
    END
    ;

    ret <-- client_activate_session_resp_sm (channel , session, activate_resp_msg) =
    BEGIN
        /* TODO: check response parameters */
        set_session_state (session, e_session_userActivated);
        ret := e_sc_ok
    END
    ;

    client_secure_channel_lost_session_sm (lost_channel, channel_config_idx) =
    VAR
        l_continue,
        l_session,
        l_valid_session,
        l_state
    IN
        l_continue <-- init_iter_channel_lost_t_session (lost_channel);
        WHILE l_continue = TRUE DO
            l_session, l_continue <-- continue_iter_orphaned_t_session;
            l_valid_session <-- is_valid_session (l_session);
            IF l_valid_session = TRUE
            THEN
                l_state <-- get_session_state (l_session);
                IF l_state = e_session_userActivated & channel_config_idx /= c_channel_config_idx_indet
                THEN
                    // Active sessions set to orphaned and channel config idx associated
                    set_session_orphaned (l_session, lost_channel, channel_config_idx);
                    set_session_state (l_session, e_session_scOrphaned)
                ELSE
                    // Inactive sessions or all orphaned sessions (if no new channel can be associated)
                    set_session_state_closed (l_session, TRUE)
                END
            END
        INVARIANT
            l_continue = bool(av_channel_sessions_to_iterate /= {}) &
            av_channel_sessions_to_iterate /\ av_channel_sessions_iterated = {} &
            av_channel_sessions_to_iterate \/ av_channel_sessions_iterated = av_channel_lost_sessions
        VARIANT
            card(av_sessions_to_iterate)
        END
    END
    ;

    server_secure_channel_lost_session_sm (channel) =
    VAR
        l_continue,
        l_session,
        l_valid_session,
        l_state
    IN
        l_continue <-- init_iter_channel_lost_t_session (channel);
        WHILE l_continue = TRUE DO
            l_session, l_continue <-- continue_iter_orphaned_t_session;
            l_valid_session <-- is_valid_session (l_session);
            IF l_valid_session = TRUE
            THEN
                l_state <-- get_session_state (l_session);
                IF l_state = e_session_userActivated
                THEN
                    set_session_orphaned (l_session, channel, c_channel_config_idx_indet);
                    set_session_state (l_session, e_session_scOrphaned)
                ELSE
                    set_session_state_closed (l_session, FALSE)
                END
            END
        INVARIANT
            l_continue = bool(av_channel_sessions_to_iterate /= {}) &
            av_channel_sessions_to_iterate /\ av_channel_sessions_iterated = {} &
            av_channel_sessions_to_iterate \/ av_channel_sessions_iterated = av_channel_lost_sessions
        VARIANT
            card(av_sessions_to_iterate)
        END
    END
    ;

    ret, channel, session_token <-- client_close_session_req_sm (session, close_req_msg) =
    VAR
        l_is_connected_channel
    IN
        channel <-- get_session_channel (session);
        l_is_connected_channel <-- is_connected_channel(channel);
        IF l_is_connected_channel = TRUE
        THEN
            session_token <-- client_get_token_from_session (session);
            /* TODO: populate msg with parameters */
            set_session_state (session, e_session_closing);
            ret := e_sc_ok
        ELSE
            channel := c_channel_indet;
            session_token := c_session_token_indet;
            ret := e_sc_bad_unexpected_error
        END
        
    END
    ;

    ret <-- server_close_session_req_and_resp_sm (channel, session, close_req_msg, close_resp_msg) =
    BEGIN
        /* TODO: actions on pending requests or current subscriptions to manage (see request) */
        /* No need to store the handle since we will send response in same step */
        /* TODO: populate msg body with parameters */
        set_session_state_closed (session, FALSE);
        ret := e_sc_ok
    END
    ;

    client_close_session_resp_sm (channel, session, close_resp_msg) =
    BEGIN
        /* In any case we close the session: correct channel or not  */
        set_session_state_closed (session, TRUE)
    END
    ;

    client_close_session_sm (session) =
    BEGIN
        set_session_state_closed (session, TRUE)
    END
    ;

    server_close_session_sm (session) =
    BEGIN
        set_session_state_closed (session, FALSE)
    END
    ;

    ret <-- is_session_valid_for_service (channel, session) =
    BEGIN
        // only for PRE compliance
        ret := TRUE
    END
    ;

    state <-- get_session_state_or_closed (session) =
    VAR
        l_valid_session
    IN
        l_valid_session <-- is_valid_session (session);
        IF l_valid_session = TRUE
        THEN
            state <-- get_session_state (session)
        ELSE
            state := e_session_closed
        END
    END
    ;

    user <-- get_session_user_or_indet (session) =
    VAR
        l_valid_session,
        l_session_state
    IN
        user := c_user_indet;
        l_valid_session <-- is_valid_session (session);
        IF l_valid_session = TRUE
        THEN
            l_session_state <-- get_session_state (session);
            IF l_session_state /= e_session_created &
                l_session_state /= e_session_creating &
                l_session_state /= e_session_closed &
                l_session_state /= e_session_init
            THEN
                user <-- get_session_user (session)
            END
        END
    END


END
